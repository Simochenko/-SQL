Выборка данных, вычисляемые столбцы, математические функции
В SQL реализовано множество  математических функций для работы с числовыми данными. В таблице приведены некоторые из них.

Функция	Описание	Пример
CEILING(x)	возвращает наименьшее целое число, большее или равное x
(округляет до целого числа в большую сторону)	CEILING(4.2)=5
CEILING(-5.8)=-5
ROUND(x, k)	округляет значение x до k знаков после запятой,
если k не указано – x округляется до целого	ROUND(4.361)=4
ROUND(5.86592,1)=5.9
FLOOR(x)	возвращает наибольшее целое число, меньшее или равное x
(округляет до  целого числа в меньшую сторону)	FLOOR(4.2)=4
FLOOR(-5.8)=-6
POWER(x, y)	возведение x в степень y	POWER(3,4)=81.0
SQRT(x)	квадратный корень из x	SQRT(4)=2.0
SQRT(2)=1.41...
DEGREES(x)	конвертирует значение x из радиан в градусы	DEGREES(3) = 171.8...
RADIANS(x)	конвертирует значение x из градусов в радианы	RADIANS(180)=3.14...
ABS(x)	модуль числа x	ABS(-1) = 1
ABS(1) = 1
PI()	pi = 3.1415926...	 
SELECT title, 
    author,
    amount,
    ROUND(price-(price*30/100),2) AS new_price 
FROM book;

SELECT author, title, 
    ROUND(IF(author = 'Булгаков М.А.', price+(price * 0.1), IF(author = 'Есенин С.А.',price+(price * 0.05), price)), 2) AS new_price 
FROM book;

Выборка данных по условию
С помощью запросов можно включать в итоговую выборку не все строки исходной таблицы, а только те, которые отвечают некоторому условию. Для этого после указания таблицы, откуда выбираются данные, задается ключевое слово WHERE и логическое выражение, от результата которого зависит будет ли включена строка в выборку или нет. Если условие – истина, то строка(запись)  включается в выборку, если ложь – нет.

Логическое выражение может включать операторы сравнения (равно «=», не равно «<>», больше «>», меньше «<», больше или равно«>=», меньше или равно «<=») и выражения, допустимые в SQL.

Пример

Вывести название и цену тех книг, цены которых меньше 600 рублей.

Запрос:

SELECT title, price 
FROM book
WHERE price < 600;
Результат:

+---------------+--------+
| title         | price  |
+---------------+--------+
| Белая гвардия | 540.50 |
| Идиот         | 460.00 |
+---------------+--------+
Вывести автора, название  и цены тех книг, количество которых меньше 10.
SELECT author, title, price 
FROM book
WHERE amount < 10;

Выборка данных, логические операции
 Логическое выражение после ключевого слова WHERE кроме операторов сравнения  и выражений может включать  логические операции (И «and», ИЛИ «or», НЕ «not») и круглые скобки, изменяющие приоритеты выполнения операций.

Приоритеты операций:

круглые скобки
умножение  (*),  деление (/)
сложение  (+), вычитание (-)
операторы сравнения (=, >, <, >=, <=, <>)
NOT
AND
OR
Пример

Вывести название, автора и цену тех книг, которые написал Булгаков, ценой больше 600 рублей

Запрос:

SELECT title, author, price 
FROM book
WHERE price > 600 AND author = 'Булгаков М.А.';
Результат:

+--------------------+---------------+--------+
| title              | author        | price  |
+--------------------+---------------+--------+
| Мастер и Маргарита | Булгаков М.А. | 670.99 |
+--------------------+---------------+--------+
 Пример

Вывести название, цену  тех книг, которые написал Булгаков или Есенин, ценой больше 600 рублей

Запрос:

SELECT title, author, price 
FROM book
WHERE (author = 'Булгаков М.А.' OR author = 'Есенин С.А.') AND price > 600;
Результат:

+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
Пояснение.
Запрос:

SELECT title, author, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Есенин С.А.' AND price > 600;
Результат (сравните с предыдущим):

+-----------------------+---------------+--------+
| title                 | author        | price  |
+-----------------------+---------------+--------+
| Мастер и Маргарита    | Булгаков М.А. | 670.99 |
| Белая гвардия         | Булгаков М.А. | 540.50 |
| Стихотворения и поэмы | Есенин С.А.   | 650.00 |
+-----------------------+---------------+--------+
Задание
Вывести название, автора,  цену  и количество всех книг, цена которых меньше 500 или больше 600, а стоимость всех экземпляров этих книг больше или равна 5000.

 Результат:

+-----------------------+-------------+--------+--------+
| title                 | author      | price  | amount |
+-----------------------+-------------+--------+--------+
| Стихотворения и поэмы | Есенин С.А. | 650.00 | 15     |
+-----------------------+-------------+--------+--------+
SELECT title, author, price, amount 
FROM book
WHERE (price > 600 OR price < 500) and (price * amount)>=5000;

Выборка данных, операторы BETWEEN, IN
 Логическое выражение после ключевого слова WHERE может включать операторы  BETWEEN и IN. Приоритет  у этих операторов такой же как у операторов сравнения, то есть они выполняются раньше, чем NOT, AND, OR.

Оператор BETWEEN позволяет отобрать данные, относящиеся к некоторому интервалу, включая его границы.

Пример

Выбрать названия и количества тех книг, количество которых от 5 до 14 включительно.

Запрос:

SELECT title, amount 
FROM book
WHERE amount BETWEEN 5 AND 14;
Результат:

+---------------+--------+
| title         | amount |
+---------------+--------+
| Белая гвардия | 5      |
| Идиот         | 10     |
+---------------+--------+
Этот запрос можно реализовать по-другому, результат будет точно такой же.

SELECT title, amount 
FROM book
WHERE amount >= 5 AND amount <=14;
Оператор  IN  позволяет выбрать данные, соответствующие значениям из списка.

Пример

Выбрать названия и цены книг, написанных Булгаковым или Достоевским.

Запрос:

SELECT title, price 
FROM book
WHERE author IN ('Булгаков М.А.', 'Достоевский Ф.М.');
Результат:

+--------------------+--------+
| title              | price  |
+--------------------+--------+
| Мастер и Маргарита | 670.99 |
| Белая гвардия      | 540.50 |
| Идиот              | 460.00 |
| Братья Карамазовы  | 799.01 |
+--------------------+--------+
Этот запрос можно реализовать по-другому, результат будет точно такой же.

SELECT title, price 
FROM book
WHERE author = 'Булгаков М.А.' OR author = 'Достоевский Ф.М.';
Задание
Вывести название и авторов тех книг, цены которых принадлежат интервалу от 540.50 до 800 (включая границы),  а количество или 2, или 3, или 5, или 7 .

Результат:

+--------------------+------------------+
| title              | author           |
+--------------------+------------------+
| Мастер и Маргарита | Булгаков М.А.    |
| Белая гвардия      | Булгаков М.А.    |
| Братья Карамазовы  | Достоевский Ф.М. |
+--------------------+------------------+

SELECT title, author
FROM book
WHERE price BETWEEN 540.50 AND 800 and amount IN (2, 3, 5, 7);

Выборка данных, оператор LIKE
Оператор LIKE используется для сравнения строк. В отличие от операторов отношения равно (=) и не равно (<>), LIKE позволяет сравнивать строки не на полное совпадение (не совпадение), а в соответствии с шаблоном. Шаблон может включать обычные символы и символы-шаблоны. При сравнении с шаблоном, его обычные символы должны в точности совпадать с символами, указанными в строке. Символы-шаблоны могут совпадать с произвольными элементами символьной строки.

Символ-шаблон	Описание	Пример
%	Любая строка, содержащая ноль или более символов	SELECT * FROM book WHERE author LIKE '%М.%'
выполняет поиск и выдает все книги, инициалы авторов которых содержат «М.»
_ (подчеркивание)	Любой одиночный символ	SELECT * FROM book WHERE title LIKE 'Поэм_'
выполняет поиск и выдает все книги, названия которых либо «Поэма», либо «Поэмы» и пр.
Пример 1

Вывести названия книг, начинающихся с буквы «Б».

Запрос:

SELECT title 
FROM book
WHERE title LIKE 'Б%';
/* эквивалентное условие 
title LIKE 'б%'
*/
Результат:

+-------------------+
| title             |
+-------------------+
| Белая гвардия     |
| Братья Карамазовы |
+-------------------+
Пояснение
Пример 2

Вывести название книг, состоящих ровно из 5 букв.

Запрос:

SELECT title FROM book 
WHERE title LIKE "_____"
Результат:

+-------+
| title | 
+-------+
| Идиот |
+-------+
Пояснение
Пример 3

Вывести книги, название которых длиннее 5 символов:

Запрос:

SELECT title FROM book 
WHERE title LIKE "______%";
/* эквивалентные условия 
title LIKE "%______"
title LIKE "%______%"
*/
Результат:

+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Белая гвардия         |
| Братья Карамазовы     |
| Стихотворения и поэмы |
| Дети полуночи         |
| Лирика                |
+-----------------------+
Пояснение  
Пример 4

Вывести названия книг, которые содержат букву "и" как отдельное слово, если считать, что слова в названии отделяются друг от друга пробелами и не содержат знаков препинания.

 Запрос:

SELECT title FROM book 
WHERE   title LIKE "_% и _%" /*отбирает слово И внутри названия */
    OR title LIKE "и _%" /*отбирает слово И в начале названия */
    OR title LIKE "_% и" /*отбирает слово И в конце названия */
    OR title LIKE "и" /* отбирает название, состоящее из одного слова И */

Результат:

+-----------------------+
| title                 |
+-----------------------+
| Мастер и Маргарита    |
| Стихотворения и поэмы |
+-----------------------+
Пояснение
Пример 5

Вывести названия книг, которые состоят ровно из одного слова, если считать, что слова в названии отделяются друг от друга пробелами .

 Запрос:

SELECT title FROM book 
WHERE title NOT LIKE "% %";    
Результат:

+-------+
| title |
+-------+
| Идиот |
+-------+
Пояснение
Задание
Вывести название и автора тех книг, название которых состоит из двух и более слов, а инициалы автора содержат букву «С». Считать, что в названии слова отделяются друг от друга пробелами и не содержат знаков препинания, между фамилией автора и инициалами обязателен пробел, инициалы записываются без пробела в формате: буква, точка, буква, точка.

Результат:

+-----------------------+-------------+
| title                 | author      |
+-----------------------+-------------+
| Стихотворения и поэмы | Есенин С.А. |
+-----------------------+-------------+
Пояснение.
Важно! Только для этого шага в таблицу добавлены новые записи.

SELECT title, author FROM book 
WHERE title LIKE "% %" and author LIKE "% С.%" and title NOT LIKE " %";

Выборка данных с сортировкой
При выборке можно указывать столбец или несколько столбцов, по которым необходимо отсортировать отобранные строки. Для этого используются ключевые слова ORDER BY, после которых задаются имена столбцов. При этом строки сортируются по первому столбцу, если указан второй столбец, сортировка осуществляется только для тех строк, у которых значения первого столбца одинаковы. По умолчанию ORDER BY выполняет сортировку по возрастанию. Чтобы управлять направлением сортировки вручную, после имени столбца указывается ключевое слово ASC (по возрастанию) или DESC (по убыванию). 

Логический порядок операций для запроса SQL следующий:

FROM
WHERE
SELECT
ORDER BY
Поскольку сортировка выполняется позже SELECT, для указания столбцов, по которым выполняется сортировка, можно использовать имена, присвоенные им после SELECT, а также порядковый номер столбца в перечислении.

Пример

Вывести название, автора и цены книг. Информацию  отсортировать по названиям книг в алфавитном порядке.

Запрос:

SELECT title, author, price
FROM book
ORDER BY title;
Результат:

+-----------------------+------------------+--------+
| title                 | author           | price  |
+-----------------------+------------------+--------+
| Белая гвардия         | Булгаков М.А.    | 540.50 |
| Братья Карамазовы     | Достоевский Ф.М. | 799.01 |
| Идиот                 | Достоевский Ф.М. | 460.00 |
| Мастер и Маргарита    | Булгаков М.А.    | 670.99 |
| Стихотворения и поэмы | Есенин С.А.      | 650.00 |
+-----------------------+------------------+--------+
Аналогичный результат получится при использовании запроса:

SELECT title, author, price
FROM book
ORDER BY 1;
Пример

Вывести автора, название и количество книг, в отсортированном в алфавитном порядке по автору и по убыванию количества, для тех книг, цены которых меньше 750 рублей.

Запрос:

SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, amount DESC;
Результат:

+------------------+-----------------------+------------+
| author           | title                 | Количество |
+------------------+-----------------------+------------+
| Булгаков М.А.    | Белая гвардия         | 5          |
| Булгаков М.А.    | Мастер и Маргарита    | 3          |
| Достоевский Ф.М. | Идиот                 | 10         |
| Есенин С.А.      | Стихотворения и поэмы | 15         |
+------------------+-----------------------+------------+
Можно использовать другие варианты записи запроса:

SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY author, Количество DESC;
SELECT author, title, amount AS Количество
FROM book
WHERE price < 750
ORDER BY 1, 3 DESC;
Важно! Если названия столбцов заключены в кавычки, то при использовании их в сортировке, необходимо записывать их БЕЗ КАВЫЧЕК.

Задание
Вывести  автора и название  книг, количество которых принадлежит интервалу от 2 до 14 (включая границы). Информацию  отсортировать по авторам (в обратном алфавитном порядке) и названиям (по алфавиту).

Результат:

+------------------+--------------------+
| author           | title              |
+------------------+--------------------+
| Достоевский Ф.М. | Братья Карамазовы  |
| Достоевский Ф.М. | Идиот              |
| Булгаков М.А.    | Белая гвардия      |
| Булгаков М.А.    | Мастер и Маргарита |
+------------------+--------------------+
SELECT author, title
FROM book
WHERE amount BETWEEN 2 AND 14
ORDER BY 1 DESC, 2

Содержание урока
SQL запросы позволяют производить вычисления не только для каждой строки таблицы, но и для группы элементов, расположенных в одном столбце. Для этого используются групповые (агрегатные) функции. 
На этом уроке рассмотрим запросы, которые реализуют:

выборку уникальных элементов столбца;
выборку данных (групповые функции sum и count);
выборку данных (групповые функции min, max и avg);
выборку данных с вычислением (групповые функции);
вычисления по таблице целиком;
выборку данных по условию (групповые функции)
выборка данных по условию (групповые функции WHERE и HAVING).
Структура и наполнение таблицы
Все запросы будут формулироваться для таблицы book(создание, заполнение):

book_id	title	author	price	amount
INT PRIMARY KEY AUTO_INCREMENT	VARCHAR(50)	VARCHAR(30)	DECIMAL(8,2)	INT
1	Мастер и Маргарита	Булгаков М.А.	670.99	3
2	Белая гвардия	Булгаков М.А.	540.50	5
3	Идиот	Достоевский Ф.М.	460.00	10
4	Братья Карамазовы	Достоевский Ф.М.	799.01	3
5	Игрок	Достоевский Ф.М.	480.50	10
6	Стихотворения и поэмы	Есенин С.А.	650.00	15

Выбор уникальных элементов столбца
Чтобы отобрать уникальные элементы некоторого столбца используется ключевое слово DISTINCT, которое размещается сразу после SELECT.

Пример

Выбрать различных авторов, книги которых хранятся в таблице book.

Запрос:

SELECT DISTINCT author
FROM book;
Результат:

+------------------+
| author           |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
+------------------+
Другой способ – использование оператора GROUP BY, который группирует данные при выборке, имеющие одинаковые значения в некотором столбце. Столбец, по которому осуществляется группировка, указывается после GROUP BY .

С помощью GROUP BY можно выбрать уникальные элементы столбца, по которому осуществляется группировка. Результат будет точно такой же как при использовании DISTINCT.

Запрос:

SELECT  author
FROM book
GROUP BY author;
Задание
Отобрать различные (уникальные) элементы столбца amount таблицы book.

Результат:

Query result:
+--------+
| amount |
+--------+
| 3      |
| 5      |
| 10     |
| 15     |
+--------+

SELECT DISTINCT amount
FROM book;

Выборка данных, групповые функции SUM и COUNT
При группировке над элементами столбца, входящими в группу можно выполнить различные действия, например, просуммировать их или найти количество элементов в группе.

При группировке данных таблицыbook по столбцу author,  получается три группы. В первую группу входят две строки, в поле author которых стоит значение «Булгаков М.А.». В столбце amountк этой группе относится значения 3 и 5.  Просуммировав эти значения, можно узнать общее количество книг Булгакова на складе. Для этого используется групповая функция SUM(). В скобках указывается столбец, по которому осуществляется суммирование.

Пример

Посчитать, сколько экземпляров книг каждого автора хранится на складе.

Запрос:

SELECT author, SUM(amount)
FROM book
GROUP BY author;
Результат:

+------------------+-------------+
| author           | SUM(amount) |
+------------------+-------------+
| Булгаков М.А.    | 8           |
| Достоевский Ф.М. | 23          |
| Есенин С.А.      | 15          |
+------------------+-------------+
Примечание
Также групповые функции позволяют посчитать сколько записей относится к каждой группе, для этого используется функция count().

Пример

Посчитать, сколько различных книг каждого автора хранится на складе.

Только для этого примера в таблицу book добавлена запись с пустыми значениями в столбцах amount и price:

+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 3      |
| 5       | Игрок                 | Достоевский Ф.М. | 480.50 | 10     |
| 6       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 7       | Черный человек        | Есенин С.А.      | Null   | Null   |
+---------+-----------------------+------------------+--------+--------+
Запрос:

/* чтобы проверить запрос, добавьте в таблицу строку */
INSERT INTO book (title, author, price, amount) VALUES ('Черный человек','Есенин С.А.', Null, Null);

SELECT author, COUNT(author), COUNT(amount), COUNT(*)
FROM book
GROUP BY author;
Результат:

+------------------+---------------+---------------+----------+
| author           | COUNT(author) | COUNT(amount) | COUNT(*) |
+------------------+---------------+---------------+----------+
| Булгаков М.А.    | 2             | 2             | 2        |
| Достоевский Ф.М. | 3             | 3             | 3        |
| Есенин С.А.      | 2             | 1             | 2        |
+------------------+---------------+---------------+----------+
Примечание

Из таблицы с результатами запроса видно, что функцию COUNT()  можно применять к любому столбцу, в том числе можно использовать и *, если таблица не содержит пустых значений. Если же в столбцах есть значения Null, (для группы по автору Есенин в нашем примере), то

COUNT(*) —  подсчитывает  все записи, относящиеся к группе, в том числе и со значением NULL;
COUNT(имя_столбца) — возвращает количество записей конкретного столбца (только NOT NULL), относящихся к группе.
ВАЖНО.

После оператора GROUP BY должны перечисляться ВСЕ неагрегированные столбцы (то есть столбцы, к которым не применены групповые функции), указанные после SELECT.
Между названием функции и скобкой НЕЛЬЗЯ СТАВИТЬ ПРОБЕЛ. Это особенность платформы.
Задание
Посчитать, количество различных книг и количество экземпляров книг каждого автора , хранящихся на складе. Вычисляемые столбцы назвать Различных_книг и Количество_экземпляров соответственно, столбец с фамилиями авторов назвать Автор.

Результат:

+------------------+----------------+------------------------+
| Автор            | Различных_книг | Количество_экземпляров |
+------------------+----------------+------------------------+
| Булгаков М.А.    | 2              | 8                      |
| Достоевский Ф.М. | 3              | 23                     |
| Есенин С.А.      | 1              | 15                     |
+------------------+----------------+------------------------+


SELECT author AS Автор, COUNT(amount) AS Различных_книг, SUM(amount) AS Количество_экземпляров
FROM book
GROUP BY author;

Выборка данных, групповые функции MIN, MAX и AVG
К групповым функциям SQL относятся: MIN(), MAX() и AVG(), которые вычисляют минимальное, максимальное и среднее значение элементов столбца, относящихся к группе.

Пример

Вывести минимальную цену книги каждого автора

Запрос:

SELECT author, MIN(price) AS min_price
FROM book
GROUP BY author;
Результат:

+------------------+-----------+
| author           | min_price |
+------------------+-----------+
| Булгаков М.А.    | 540.50    |
| Достоевский Ф.М. | 460.00    |
| Есенин С.А.      | 650.00    |
+------------------+-----------+
Задание
Вывести минимальную, максимальную и среднюю цену книг каждого автора . Вычисляемые столбцы назвать Минимальная_цена, Максимальная_цена и Средняя_цена соответственно.

Результат:

+------------------+------------------+-------------------+--------------+
| author           | Минимальная_цена | Максимальная_цена | Средняя_цена |
+------------------+------------------+-------------------+--------------+
| Булгаков М.А.    | 540.50           | 670.99            | 605.745000   |
| Достоевский Ф.М. | 460.00           | 799.01            | 579.836667   |
| Есенин С.А.      | 650.00           | 650.00            | 650.000000   |
+------------------+------------------+-------------------+--------------+

SELECT author, MIN(price) AS Минимальная_цена, MAX(price) AS Максимальная_цена, AVG(price) AS Средняя_цена
FROM book
GROUP BY author;

Выборка данных c вычислением, групповые функции
В качестве аргумента групповых функций  SQL может использоваться не только столбец, но и любое допустимое в SQL арифметическое выражение.

Пример

Вывести суммарную стоимость книг каждого автора.

Запрос:

SELECT author, SUM(price * amount) AS Стоимость
FROM book
GROUP BY author;
Результат:

+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Булгаков М.А.    | 4715.47   |
| Достоевский Ф.М. | 11802.03  |
| Есенин С.А.      | 9750.00   |
+------------------+-----------+
Групповые функции могут быть элементами выражений. Например, при вычислении средней стоимости книг каждого автора на предыдущем шаге получились значения с шестью знаками после запятой. А поскольку это деньги, значения нужно округлить до 2 знаков после запятой.

 Пример

Найти среднюю цену книг каждого автора.

Запрос:

SELECT author, ROUND(AVG(price),2) AS Средняя_цена
FROM book
GROUP BY author;
Результат:

+------------------+--------------+
| author           | Средняя_цена |
+------------------+--------------+
| Булгаков М.А.    | 605.75       |
| Достоевский Ф.М. | 579.84       |
| Есенин С.А.      | 650.00       |
+------------------+--------------+
Задание
Для каждого автора вычислить суммарную стоимость книг S (имя столбца Стоимость), а также вычислить налог на добавленную стоимость  для полученных сумм (имя столбца НДС ) , который включен в стоимость и составляет k = 18%,  а также стоимость книг  (Стоимость_без_НДС) без него. Значения округлить до двух знаков после запятой. В запросе для расчета НДС(tax)  и Стоимости без НДС(S_without_tax) использовать следующие формулы:

tax= (S *{ k / 100})/ {1+{k/ 100}}},


S_without_tax= {{S}/ {1+{k/ 100}}}

 

Результат:

+------------------+-----------+---------+-------------------+
| author           | Стоимость | НДС     | Стоимость_без_НДС |
+------------------+-----------+---------+-------------------+
| Булгаков М.А.    | 4715.47   | 719.31  | 3996.16           |
| Достоевский Ф.М. | 11802.03  | 1800.31 | 10001.72          |
| Есенин С.А.      | 9750.00   | 1487.29 | 8262.71           |
+------------------+-----------+---------+-------------------+
SELECT author, SUM(price * amount) AS Стоимость, ROUND((SUM(price * amount)*(18/100))/(1+(18/100)),2) AS НДС,
 ROUND((SUM(price * amount))/(1+(18/100)),2) AS Стоимость_без_НДС
FROM book
GROUP BY author;

Вычисления по таблице целиком
Групповые функции позволяют вычислять итоговые значения по всей таблице. Например, можно посчитать общее количество книг на складе, вычислить суммарную стоимость и пр. Для этого после ключевого слова SELECT указывается групповая функция для выражения или имени столбца, а ключевые слова GROUP BY опускаются.

Пример

Посчитать количество экземпляров книг на складе.

Запрос:

SELECT SUM(amount) AS Количество
FROM book;
Результат:

+------------+
| Количество |
+------------+
| 46         |
+------------+ 
Результатом таких запросов является единственная строка с вычисленными по таблице значениями.

 Пример

Посчитать общее количество экземпляров книг на складе и их стоимость .

Запрос:

SELECT SUM(amount) AS Количество, 
    SUM(price * amount) AS Стоимость
FROM book;
Результат:

+------------+-----------+
| Количество | Стоимость |
+------------+-----------+
| 46         | 26267.50  |
+------------+-----------+
Задание
Вывести  цену самой дешевой книги, цену самой дорогой и среднюю цену книг на складе. Названия столбцов Минимальная_цена, Максимальная_цена, Средняя_цена соответственно. Среднюю цену округлить до двух знаков после запятой.

Результат:

+------------------+-------------------+--------------+
| Минимальная_цена | Максимальная_цена | Средняя_цена |
+------------------+-------------------+--------------+
| 460.00           | 799.01            | 600.17       |
+------------------+-------------------+--------------+

SELECT MIN(price) AS Минимальная_цена, 
    MAX(price)AS Максимальная_цена, ROUND(AVG(price),2) AS Средняя_цена
FROM book;


Выборка данных по условию, групповые функции
В запросы с групповыми функциями можно включать условие отбора строк, которое в обычных запросах записывается после WHERE. В запросах с групповыми функциями вместо WHERE используется ключевое слово HAVING , которое размещается после оператора GROUP BY.

Пример

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000.

Запрос:

SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000; 
Результат:

+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
| Есенин С.А.      | 650.00           | 650.00            |
+------------------+------------------+-------------------+
Также в запросах с группировкой можно сортировать данные.

 Пример

Найти минимальную и максимальную цену книг всех авторов, общая стоимость книг которых больше 5000. Результат вывести по убыванию минимальной цены.

Запрос:

SELECT author,
    MIN(price) AS Минимальная_цена, 
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(price * amount) > 5000 
ORDER BY Минимальная_цена DESC;
Результат:

+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Есенин С.А.      | 650.00           | 650.00            |
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
Пояснение
Задание
Вычислить среднюю цену и суммарную стоимость тех книг, количество экземпляров которых принадлежит интервалу от 5 до 14, включительно. Столбцы переименовать как показано в образце, значения округлить до 2-х знаков после запятой.

Результат:

+--------------+-----------+
| Средняя_цена | Стоимость |
+--------------+-----------+
| 493.67       | 12107.50  |
+--------------+-----------+

SELECT ROUND(AVG(price),2) AS Средняя_цена,
    SUM(price*amount) AS Стоимость
FROM book
WHERE amount BETWEEN 5 AND 14 


Выборка данных по условию, групповые функции, WHERE и HAVING
Для этого урока теоретическая часть подготовлена Alexandra Klinnikova, спасибо большое!

WHERE и HAVING могут использоваться в одном запросе. При этом необходимо учитывать порядок выполнения  SQL запроса на выборку на сервере:

FROM
WHERE
GROUP BY
HAVING
SELECT
ORDER BY
Сначала определяется таблица, из которой выбираются данные (FROM), затем из этой таблицы отбираются записи в соответствии с условием  WHERE, выбранные данные агрегируются (GROUP BY),  из агрегированных записей выбираются те, которые удовлетворяют условию после HAVING. Потом формируются данные результирующей выборки, как это указано после SELECT ( вычисляются выражения, присваиваются имена и пр. ). Результирующая выборка сортируется, как указано после ORDER BY.

Важно! Порядок ВЫПОЛНЕНИЯ запросов - это не порядок ЗАПИСИ ключевых слов в запросе на выборку. Порядок записи (синтаксис запроса) остается таким же, как рассматривался ранее в курсе. Порядок ВЫПОЛНЕНИЯ  нужен для того, чтобы понять, почему, например, в WHERE нельзя использовать имена выражений из SELECT. Просто SELECT выполняется компилятором позже, чем WHERE, поэтому ему неизвестно, какое там выражение написано.

Пример

Вывести максимальную и минимальную цену книг каждого автора, кроме Есенина, количество экземпляров книг которого больше 10. 

SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
WHERE author <> 'Есенин С.А.'
GROUP BY author
HAVING SUM(amount) > 10;
Результат:

+------------------+------------------+-------------------+
| author           | Минимальная_цена | Максимальная_цена |
+------------------+------------------+-------------------+
| Достоевский Ф.М. | 460.00           | 799.01            |
+------------------+------------------+-------------------+
 Этот запрос будет работать, если его переписать следующим образом:

SELECT author,
    MIN(price) AS Минимальная_цена,
    MAX(price) AS Максимальная_цена
FROM book
GROUP BY author
HAVING SUM(amount) > 10 AND author <> 'Есенин С.А.';
Не смотря на то что результат будет одинаковым, так делать не рекомендуется. «Потому что как написано - запрос сначала выбирает всех авторов, потом выводит данные, рассчитывая минимальное и максимальное значение цены для каждого, и только после всего убирает Есенина. Можно убрать Есенина в данном случае раньше и не использовать ресурсы базы для расчета его минимального и максимального значения, как это сделано в первом варианте. На небольшой базе быстродействия не ощутить, но если выполнять такое на продуктивной, то второй вариант значительно проигрывает...»[Alexandra Klinnikova].

Задание
Посчитать стоимость всех экземпляров каждого автора без учета книг «Идиот» и «Белая гвардия». В результат включить только тех авторов, у которых суммарная стоимость книг более 5000 руб. Результат отсортировать по убыванию стоимости.

+------------------+-----------+
| author           | Стоимость |
+------------------+-----------+
| Есенин С.А.      | 9750.00   |
| Достоевский Ф.М. | 7202.03   |
+------------------+-----------+

SELECT author,
    SUM(price*amount) AS Стоимость
FROM book
WHERE title <> 'Идиот' OR 'Белая гвардия'
GROUP BY author
HAVING SUM(price*amount) > 5000
ORDER BY Стоимость DESC;


Вложенный запрос, возвращающий одно значение
Вложенный запрос, возвращающий одно значение, может использоваться в условии отбора записей WHERE как обычное значение совместно с операциями =, <>, >=, <=, >, <.

Пример

Вывести информацию о самых дешевых книгах, хранящихся на складе.

Для реализации этого запроса нам необходимо получить минимальную цену из столбца price таблицы book, а затем вывести информацию о тех книгах, цена которых  равна минимальной. Первая часть  – поиск  минимума – реализуется вложенным запросом.

Запрос:

SELECT title, author, price, amount
FROM book
WHERE price = (
         SELECT MIN(price) 
         FROM book
      );
Результат:

+-------+------------------+--------+--------+
| title | author           | price  | amount |
+-------+------------------+--------+--------+
| Идиот | Достоевский Ф.М. | 460.00 | 10     |
+-------+------------------+--------+--------+
Вложенный запрос определяет минимальную цену книг во всей таблице (это 460.00), а затем в основном запросе для каждой записи проверяется, равна ли цена минимальному значению, если равна, информация о книге включается в результирующую таблицу запроса.

Рекомендация. При использовании вложенного запроса рекомендуется сначала проверить, правильно ли он работает (занести текст запроса в окно кода и нажать черную кнопку Запустить), если выдается верный результат – использовать код в качестве вложенного запроса.

Задание
Вывести информацию (автора, название и цену) о  книгах, цены которых меньше или равны средней цене книг на складе. Информацию вывести в отсортированном по убыванию цены виде. Среднее вычислить как среднее по цене книги.

Результат:

+------------------+---------------+--------+
| author           | title         | price  |
+------------------+---------------+--------+
| Булгаков М.А.    | Белая гвардия | 540.50 |
| Достоевский Ф.М. | Игрок         | 480.50 |
| Достоевский Ф.М. | Идиот         | 460.00 |
+------------------+---------------+--------+

SELECT  author, title, price
FROM book
WHERE price <= (
         select ROUND(AVG(price),2) AS AVG_PRICE
         from book
)
ORDER BY price DESC;

Использование вложенного запроса в выражении
Вложенный запрос, возвращающий одно значение, может использоваться в выражениях как обычный операнд, например, к нему можно что-то прибавить, отнять и пр.

Пример

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3. То есть нужно вывести и те книги, количество экземпляров которых меньше среднего на 3, и больше среднего на 3.

Запрос:

SELECT title, author, amount 
FROM book
WHERE ABS(amount - (SELECT AVG(amount) FROM book)) >3;
Результат:

+-----------------------+------------------+--------+
| title                 | author           | amount |
+-----------------------+------------------+--------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      |
| Братья Карамазовы     | Достоевский Ф.М. | 3      |
| Стихотворения и поэмы | Есенин С.А.      | 15     |
+-----------------------+------------------+--------+
Задание
Вывести информацию (автора, название и цену) о тех книгах, цены которых превышают минимальную цену книги на складе не более чем на 150 рублей в отсортированном по возрастанию цены виде.

Результат:

+------------------+----------------+--------+
| author           | title          | price  |
+------------------+----------------+--------+
| Достоевский Ф.М. | Идиот          | 460.00 |
| Достоевский Ф.М. | Игрок          | 480.50 |
| Булгаков М.А.    | Белая гвардия  | 540.50 |
| Пушкин А.С.      | Евгений Онегин | 610.00 |
+------------------+----------------+--------+

SELECT author, title, price
FROM book
WHERE price -(SELECT MIN(price) FROM book) <= 150
ORDER BY price
;


Вложенный запрос, оператор IN
Вложенный запрос может возвращать несколько значений одного столбца.  Оператор IN определяет, совпадает ли указанное в логическом выражении значение с одним из значений, содержащихся во вложенном запросе ,  при этом логическое выражение получает значение истина. Оператор NOT IN выполняет обратное действие – выражение истинно, если значение не содержится во вложенном запросе.

Пример

Вывести информацию о книгах тех авторов, общее количество экземпляров книг которых не менее 12.

Запрос:

SELECT title, author, amount, price
FROM book
WHERE author IN (
        SELECT author 
        FROM book 
        GROUP BY author 
        HAVING SUM(amount) >= 12
      );
Результат:

+-----------------------+------------------+--------+--------+
| title                 | author           | amount | price  |
+-----------------------+------------------+--------+--------+
| Идиот                 | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 799.01 |
| Игрок                 | Достоевский Ф.М. | 10     | 480.50 |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 650.00 |
+-----------------------+------------------+--------+--------+
Вложенный запрос отбирает двух авторов (Достоевского и Есенина). А в основном запросе для каждой записи таблицы book  проверяется, входит ли автор книги в отобранный список, если входит - информация о книге включается в запрос.

Задание
Вывести информацию (автора, книгу и количество) о тех книгах, количество экземпляров которых в таблице book не повторяется.

Результат:

+---------------+-----------------------+--------+
| author        | title                 | amount |
+---------------+-----------------------+--------+
| Булгаков М.А. | Белая гвардия         | 5      |
| Есенин С.А.   | Стихотворения и поэмы | 15     |
+---------------+-----------------------+--------+

SELECT  author,title, amount
FROM book
WHERE amount IN(select amount
from book
GROUP BY amount
HAVING count(amount) = 1);

Вложенный запрос, операторы ANY и ALL
 Вложенный запрос, возвращающий несколько значений одного столбца, можно использовать для отбора записей с помощью операторов ANY и ALL совместно с операциями отношения (=, <>, <=, >=, <, >).

Операторы ANY и ALL используются  в SQL для сравнения некоторого значения с результирующим набором вложенного запроса, состоящим из одного столбца. При этом тип данных столбца, возвращаемого вложенным запросом, должен совпадать с типом данных столбца (или выражения), с которым происходит сравнение.

При использовании оператора ANY в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно хотя бы для одного элемента результирующего запроса. Как работает оператор ANY():

amount > ANY (10, 12) эквивалентно amount > 10

amount < ANY (10, 12) эквивалентно amount < 12

amount = ANY (10, 12) эквивалентно (amount = 10) OR (amount = 12), а также amount IN  (10,12)

amount <> ANY (10, 12) вернет все записи с любым значением amount, включая 10 и 12

При использовании оператора ALL в результирующую таблицу будут включены все записи, для которых  выражение со знаком отношения верно для всех элементов результирующего запроса. Как работает оператор ALL:

amount > ALL (10, 12) эквивалентно amount > 12

amount < ALL (10, 12) эквивалентно amount < 10

amount = ALL (10, 12) не вернет ни одной записи, так как эквивалентно (amount = 10) AND (amount = 12)
amount <> ALL (10, 12) вернет все записи кроме тех,  в которыхamount равно 10 или 12

Важно! Операторы ALL и ANY можно использовать только с вложенными запросами. В примерах выше (10, 12) приводится как результат вложенного запроса просто для того, чтобы показать как эти операторы работают. В запросах так записывать нельзя.

Пример

Вывести информацию о тех книгах, количество которых меньше самого маленького среднего количества книг каждого автора.

Запрос:

SELECT title, author, amount, price
FROM book
WHERE amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
Результат:

+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
+--------------------+------------------+--------+--------+
Пояснение
1. Вложенный запрос

SELECT AVG(amount) 
        FROM book 
        GROUP BY author
отбирает следующие записи:

+-------------+
| AVG(amount) |
+-------------+
| 4.0000      |
| 7.6667      |
| 15.0000     |
+-------------+
2. Условие отбора в основном запросе

amount < ALL (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      )
можно переписать (если заменить вложенный запрос списком отобранных значений):

amount < ALL ( 4.0000, 7.6667, 15.0000)
что в соответствии с определением ALL, это значит, что подходят все amount меньшие 4.000.

Таким образом, наш запрос отобрал все книги книги Мастер и Маргарита и Братья Карамазовы, количество которых равно 3. 

Пример

Вывести информацию о тех книгах, количество которых меньше самого большого среднего количества книг каждого автора.

Запрос:

SELECT title, author, amount, price
FROM book
WHERE amount < ANY (
        SELECT AVG(amount) 
        FROM book 
        GROUP BY author 
      );
Результат:

+--------------------+------------------+--------+--------+
| title              | author           | amount | price  |
+--------------------+------------------+--------+--------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 670.99 |
| Белая гвардия      | Булгаков М.А.    | 5      | 540.50 |
| Идиот              | Достоевский Ф.М. | 10     | 460.00 |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 799.01 |
| Игрок              | Достоевский Ф.М. | 10     | 480.50 |
+--------------------+------------------+--------+--------+
Пояснение
В этом примере amount < ANY ( 4.0000, 7.6667, 15.0000)  означает, что подходят amount меньше самого большого значения из списка.

Задание
Вывести информацию о книгах(автор, название, цена), цена которых меньше самой большой из минимальных цен, вычисленной для каждого автора.

Результат:

+------------------+---------------+--------+
| author           | title         | price  |
+------------------+---------------+--------+
| Булгаков М.А.    | Белая гвардия | 540.50 |
| Достоевский Ф.М. | Идиот         | 460.00 |
| Достоевский Ф.М. | Игрок         | 480.50 |
+------------------+---------------+--------+

SELECT author, title,  price
FROM book
WHERE price < ANY (
        SELECT MIN(price) 
        FROM book 
        GROUP BY author 
      );
	  
	  
Вложенный запрос после SELECT
 Вложенный запрос может располагаться после ключевого слова SELECT. В этом случае результат выполнения запроса выводится в отдельном столбце результирующей таблицы. При этом результатом запроса может быть либо одно значение, тогда оно будет повторяться во всех строках, либо несколько значений, количество которых равно количеству отобранных записей в основном запросе.

Пример

Вывести информацию о книгах, количество экземпляров которых отличается от среднего количества экземпляров книг на складе более чем на 3,  а также указать среднее значение количества экземпляров книг.

Запрос:

SELECT title, author, amount, 
    (
     SELECT AVG(amount) 
     FROM book
    ) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
Результат:

+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7.6667             |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7.6667             |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7.6667             |
+-----------------------+------------------+--------+--------------------+
Во вложенном запросе вычисляется среднее количество экземпляров книг на складе. Этот запрос используется и в условии отбора, и для создания столбца Среднее_количество в результирующей таблице запроса. Значения  столбца одинаковы во всех строках, поскольку  вложенный запрос возвращает одно значение.

Среднее количество в виде дробного числа выглядит не очень правильно. Полученное значение можно округлить "вниз" - до ближайшего меньшего целого.

Запрос:

SELECT title, author, amount, 
      FLOOR((SELECT AVG(amount) FROM book)) AS Среднее_количество 
FROM book
WHERE abs(amount - (SELECT AVG(amount) FROM book)) >3;
Результат:

+-----------------------+------------------+--------+--------------------+
| title                 | author           | amount | Среднее_количество |
+-----------------------+------------------+--------+--------------------+
| Мастер и Маргарита    | Булгаков М.А.    | 3      | 7                  |
| Братья Карамазовы     | Достоевский Ф.М. | 3      | 7                  |
| Стихотворения и поэмы | Есенин С.А.      | 15     | 7                  |
+-----------------------+------------------+--------+--------------------+
Задание
Посчитать сколько и каких экземпляров книг нужно заказать поставщикам, чтобы на складе было одинаковое количество экземпляров каждой книги, равное значению самого большего количества экземпляров одной книги на складе. Столбцу с количеством заказываемых экземпляров книг присвоить имя Заказ.

Результат:

+--------------------+------------------+--------+-------+
| title              | author           | amount | Заказ |
+--------------------+------------------+--------+-------+
| Мастер и Маргарита | Булгаков М.А.    | 3      | 12    |
| Белая гвардия      | Булгаков М.А.    | 5      | 10    |
| Идиот              | Достоевский Ф.М. | 10     | 5     |
| Братья Карамазовы  | Достоевский Ф.М. | 3      | 12    |
| Игрок              | Достоевский Ф.М. | 10     | 5     |
+--------------------+------------------+--------+-------+
Пояснение
Поскольку книгу с максимальным количеством экземпляров заказывать не нужно, в условии отбора запроса укажите,
 что книгу с максимальным значением количества в результирующую таблицу не включать. 	  
 
 
 SELECT title, author, amount, 
      FLOOR((SELECT MAX(amount) FROM book)- amount) AS Заказ 
FROM book
WHERE amount <> 15



Добавление записей из другой таблицы
С помощью запроса на добавление можно не только добавить в таблицу конкретные значения (список VALUES), но и записи из другой таблицы, отобранные с помощью запроса на выборку.  В этом случае вместо раздела VALUES записывается запрос на выборку, начинающийся с SELECT.  В нем можно использовать WHERE, GROUP BY, ORDER BY.

Правила соответствия между полями таблицы и вставляемыми значениями из запроса:

количество полей в таблице и количество полей в запросе должны совпадать;
должно существовать прямое соответствие между позицией одного и того же элемента в обоих списках, поэтому первый столбец запроса должен относиться к первому столбцу в списке столбцов таблицы, второй – ко второму столбцу и т.д.
 типы столбцов запроса должны быть совместимы с типами данных соответствующих столбцов таблицы ( целое число можно занести в поле типа DECIMAL, обратная операция – недопустима).
Пример

Занести все книги из таблицы supply в таблицу book.

Запрос:

INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply;

SELECT * FROM book;
Результат:

Affected rows: 4
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
| 8       | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 9       | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
+---------+-----------------------+------------------+--------+--------+
Affected rows: 9
С помощью этого запроса в таблицу book включены все книги из supply, даже те, которые в book уже есть («Белая гвардия» и «Идиот»). В результате в таблице одна и та же книга, например «Белая гвардия», имеет код 2 и 8. Для реляционной модели это нежелательная ситуация. Устранить эту проблему можно с помощью вложенных запросов, которые будут рассмотрены в следующем шаге.

Задание
Добавить из таблицы supply в таблицу book, все книги, кроме книг, написанных Булгаковым М.А. и Достоевским Ф.М.

Результат:

Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+


Добавление записей, вложенные запросы
В запросах на добавление можно использовать вложенные запросы.

Пример

Занести из таблицы supply в таблицу book только те книги, названия которых отсутствуют в таблице book.

Запрос:

INSERT INTO book (title, author, price, amount) 
SELECT title, author, price, amount 
FROM supply
WHERE title NOT IN (
        SELECT title 
        FROM book
      );

SELECT * FROM book;
Результат:

Affected rows: 2

Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
| 7       | Черный человек        | Есенин С.А.      | 570.20 | 6      |
+---------+-----------------------+------------------+--------+--------+
Вложенным запросом отбираются все названия книг, которые есть в таблице book. Основным запросом SELECT из таблицы supply выбираются книги, названия которых нет в результате вложенного запроса. Отобранные записи добавляются в конец таблицы bookзапросом на добавление INSERT.

Задание
Занести из таблицы supply в таблицу book только те книги, авторов которых нет в  book.

Результат:

Affected rows: 1

Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
| 6       | Лирика                | Пастернак Б.Л.   | 518.99 | 2      |
+---------+-----------------------+------------------+--------+--------+


Запросы на обновление
Под обновлением данных подразумевается изменение значений в существующих записях таблицы. При этом возможно как изменение значений полей в группе строк (даже всех строк таблицы), так и правка значения поля отдельной строки.

Изменение записей в таблице реализуется с помощью запроса UPDATE. Простейший запрос на  обновление выглядит так:

UPDATE таблица SET поле = выражение
где 
таблица – имя таблицы, в которой будут проводиться изменения;
поле – поле таблицы, в которое будет внесено изменение;
выражение – выражение,  значение которого будет занесено в поле.

Пример

Уменьшить на 30% цену книг в таблице book.

Запрос:

UPDATE book 
SET price = 0.7 * price;

SELECT * FROM book;
Результат:

Affected rows: 5
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 378.35 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 322.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 455.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
С помощью запросов на обновление можно изменять не все записи в таблице (как в предыдущем запросе), а только часть из них. Для этого в запрос включается ключевое слово WHERE, после которого указывается условие отбора строк для изменения.

Пример

Уменьшить на 30% цену тех книг в таблице book, количество которых меньше 5.

Запрос:

UPDATE book 
SET price = 0.7 * price 
WHERE amount < 5;

SELECT * FROM book;
Результат:

Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 469.69 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 559.31 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
В этом запросе обновляется только 2 записи (цена книг «Мастер и Маргарита» и «Братья Карамазовы»).

Задание
Уменьшить на 10% цену тех книг в таблице book, количество которых принадлежит интервалу от 5 до 10 включительно.


Результат:

Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 486.45 | 5      |
| 3       | Идиот                 | Достоевский Ф.М. | 414.00 | 10     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
UPDATE book 
SET price = 0.9 * price 
WHERE amount BETWEEN 5 AND 10 ;
SELECT * FROM book;


Запросы на обновление нескольких столбцов
Запросом UPDATE можно обновлять значения нескольких столбцов одновременно. В этом случае простейший запрос будет выглядеть так:

UPDATE таблица SET поле1 = выражение1, поле2 = выражение2
На складе, кроме хранения и получения книг, выполняется их оптовая продажа. Для реализации этого действия включим дополнительный столбец buy в таблицу book:

book_id	title	author	price	amount	buy
INT PRIMARY KEY AUTO_INCREMENT	VARCHAR(50)	VARCHAR(30)	DECIMAL(8,2)	INT	int
1	Мастер и Маргарита	Булгаков М.А.	670.99	3	0
2	Белая гвардия	Булгаков М.А.	540.50	5	3
3	Идиот	Достоевский Ф.М.	460.00	10	8
4	Братья Карамазовы	Достоевский Ф.М.	799.01	2	0
5	Стихотворения и поэмы	Есенин С.А.	650.00	15	18
Пример

В столбце buy покупатель указывает количество книг, которые он хочет приобрести. Для каждой книги, выбранной покупателем, необходимо уменьшить ее количество на складе на указанное в столбцеbuy количество, а в столбец buy занести 0.

Запрос:

UPDATE book 
SET amount = amount - buy,
    buy = 0;

SELECT * FROM book;
Результат:

Affected rows: 3
Query result:
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 2      | 0   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 2      | 0   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | -3     | 0   |
+---------+-----------------------+------------------+--------+--------+-----+
Как видно из таблицы, без проверки данных, которые занесены в столбец,  нельзя запускать запрос на обновление (может получиться отрицательное значение количества).

Задание
В таблице book необходимо скорректировать значение для покупателя в столбце buy таким образом, чтобы оно не превышало допустимый остаток в столбце amount. А цену тех книг, которые покупатель не заказывал, снизить на 10%.

Результат:

Affected rows: 3
Query result:
+---------+-----------------------+------------------+--------+--------+-----+
| book_id | title                 | author           | price  | amount | buy |
+---------+-----------------------+------------------+--------+--------+-----+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 603.89 | 3      | 0   |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 5      | 3   |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 10     | 8   |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 719.11 | 2      | 0   |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     | 15  |
+---------+-----------------------+------------------+--------+--------+-----+
Пояснение
 Запрос на обновление количества книг должен корректировать значения в столбце   buy  таблицы book следующим образом:

если покупатель заказал количество книг больше, чем есть на складе, то заменить значение buy на имеющееся на складе количество amount;
если покупатель хочет купить количество книг меньшее или равное количеству книг на складе, то значение buy изменять не надо.


UPDATE book 
SET  price = ROUND(IF(buy = 0, price*0.9, price), 2), buy = IF(buy > amount, amount, buy);
SELECT * FROM book;

Запросы на обновление нескольких таблиц 
В запросах на обновление можно использовать несколько таблиц, но тогда

для столбцов, имеющих одинаковые имена, необходимо указывать имя таблицы, к которой они относятся, например, book.price – столбец price из таблицы book, supply.price – столбец price из таблицы supply;
все таблицы, используемые в запросе, нужно перечислить после ключевого слова UPDATE;
в запросе обязательно условие WHERE, в котором указывается условие при котором обновляются данные.
Пример

Если в таблице supply  есть те же книги, что и в таблице book, добавлять эти книги в таблицу book не имеет смысла. Необходимо увеличить их количество на значение столбца amountтаблицы supply.

Запрос:

UPDATE book, supply 
SET book.amount = book.amount + supply.amount
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;
Результат:

Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 460.00 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
В этом запросе увеличилось количество двух книг: «Белая гвардия», которая в supply имеет ту же цену, и «Идиот», но цена этой книги в таблицах book и supply отличается. Для этой книги нужно пересчитать цену.

Задание
Для тех книг в таблице book , которые есть в таблице supply, не только увеличить их количество в таблице book( увеличить их количество на значение столбца amountтаблицы supply), но и пересчитать их цену (для каждой книги найти сумму цен из таблиц book и supply и разделить на 2).

Результат:

Affected rows: 2
Query result:
+---------+-----------------------+------------------+--------+--------+
| book_id | title                 | author           | price  | amount |
+---------+-----------------------+------------------+--------+--------+
| 1       | Мастер и Маргарита    | Булгаков М.А.    | 670.99 | 3      |
| 2       | Белая гвардия         | Булгаков М.А.    | 540.50 | 12     |
| 3       | Идиот                 | Достоевский Ф.М. | 410.40 | 13     |
| 4       | Братья Карамазовы     | Достоевский Ф.М. | 799.01 | 2      |
| 5       | Стихотворения и поэмы | Есенин С.А.      | 650.00 | 15     |
+---------+-----------------------+------------------+--------+--------+
Пояснение
Структура и наполнение таблиц book и supply:

UPDATE book, supply 
SET book.amount = book.amount + supply.amount, book.price = (book.price + supply.price)/2
WHERE book.title = supply.title AND book.author = supply.author;

SELECT * FROM book;

Запросы на удаление
Запросы корректировки данных позволяют удалить одну или несколько записей из  таблицы. Простейший запрос на удаление имеет вид:

DELETE FROM таблица;
Этот запрос удаляет все записи из указанной после FROM таблицы.

Пример

После того, как информация о книгах из таблицы supply перенесена в book , необходимо очистить таблицу  supply.

Запрос:

DELETE FROM supply;

SELECT * FROM supply;
Результат:

Affected rows: 4
Affected rows: 0
Из таблицы удалены все записи. Запрос на выборку отобрал 0 записей.

Запрос на удаления позволяет удалить не все записи таблицы, а только те, которые удовлетворяют условию, указанному после ключевого слова WHERE:

DELETE FROM таблица
WHERE условие;
Пример

Удалить из таблицы supply все книги, названия которых есть в таблице book.

Запрос:

DELETE FROM supply 
WHERE title IN (
        SELECT title 
        FROM book
      );


SELECT * FROM supply;
Результат:

Affected rows: 2

Query result:
+-----------+--------------------------+------------------+--------+--------+
| supply_id | title                    | author           | price  | amount |
+-----------+--------------------------+------------------+--------+--------+
| 1         | Лирика                   | Пастернак Б.Л.   | 518.99 | 2      |
| 2         | Черный человек           | Есенин С.А.      | 570.20 | 6      |
+-----------+--------------------------+------------------+--------+--------+
Из таблицы supply удалены две записи о книгах «Белая гвардия» и «Идиот».

Задание
Удалить из таблицы supply книги тех авторов, общее количество экземпляров книг которых в таблице book превышает 10.

Результат:

Affected rows: 2

Query result:
+-----------+---------------+----------------+--------+--------+
| supply_id | title         | author         | price  | amount |
+-----------+---------------+----------------+--------+--------+
| 1         | Лирика        | Пастернак Б.Л. | 518.99 | 2      |
| 3         | Белая гвардия | Булгаков М.А.  | 540.50 | 7      |
+-----------+---------------+----------------+--------+--------+
Структура и наполнение таблиц book и supply:

DELETE FROM supply 
WHERE author IN (
        SELECT author FROM book
        where amount >=10
        group by author        
     );
SELECT * FROM supply;


Запросы на создание таблицы
Новая таблица может быть создана на основе данных из другой таблицы. Для этого используется запрос SELECT, результирующая таблица которого и будет новой таблицей базы данных. При этом имена столбцов запроса становятся именами столбцов новой таблицы. Запрос на создание новой таблицы имеет вид:

CREATE TABLE имя_таблицы AS
SELECT ...
Пример

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое количество экземпляров 5.

Запрос:

CREATE TABLE ordering AS
SELECT author, title, 5 AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
Результат:

Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 5      |
| Достоевский Ф.М. | Братья Карамазовы  | 5      |
+------------------+--------------------+--------+
При создании таблицы можно использовать вложенные запросы как после SELECT, так и после WHERE.

Пример

Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше 4. Для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

Запрос:

CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE amount < 4;

SELECT * FROM ordering;
Результат:

Affected rows: 2
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 7      |
| Достоевский Ф.М. | Братья Карамазовы  | 7      |
+------------------+--------------------+--------+
Задание
Создать таблицу заказ (ordering), куда включить авторов и названия тех книг, количество экземпляров которых в таблице book меньше среднего количества экземпляров книг в таблице book. В таблицу включить столбец   amount, в котором для всех книг указать одинаковое значение - среднее количество экземпляров книг в таблице book.

Результат:

Affected rows: 3
Query result:
+------------------+--------------------+--------+
| author           | title              | amount |
+------------------+--------------------+--------+
| Булгаков М.А.    | Мастер и Маргарита | 7      |
| Булгаков М.А.    | Белая гвардия      | 7      |
| Достоевский Ф.М. | Братья Карамазовы  | 7      |
+------------------+--------------------+--------+
Структура и наполнение таблицы book:

CREATE TABLE ordering AS
SELECT author, title, 
   (
    SELECT ROUND(AVG(amount)) 
    FROM book
   ) AS amount
FROM book
WHERE book.amount < 7 ;   

SELECT * FROM ordering;


CREATE TABLE ordering AS
SELECT author, title,
   (
    SELECT ROUND(AVG(price)) 
    FROM book
   ) AS price
FROM book
WHERE book.price < 500 ;   

SELECT * FROM ordering;


Для SQL Server

 

 

create table trip
(
    trip_id INT PRIMARY KEY AUTO_INCREMENT,
    [name] varchar(30),
    city varchar(25),
    per_diem decimal(8,2),
    date_first date,
    date_last date
)

insert into trip ([name],city,per_diem,date_first,date_last) 
values
('Баранов П.Е.','Москва',700 , '2020-01-12', '2020-01-17'),
('Абрамова К.А.','Владивосток',450 , '2020-01-14', '2020-01-27'),
('Семенов И.В.','Москва',700 , '2020-01-23', '2020-01-31'),
('Ильиных Г.Р.','Владивосток', 450, '2020-01-12', '2020-02-02'),
('Колесов С.П.','Москва',700 , '2020-02-01', '2020-02-06'),
('Баранов П.Е.','Москва', 700, '2020-02-14', '2020-02-22'),
('Абрамова К.А.','Москва', 700, '2020-02-23', '2020-03-01'),
('Лебедев Т.К.','Москва', 700, '2020-03-03', '2020-03-06'),
('Колесов С.П.','Новосибирск',450 , '2020-02-27', '2020-03-12'),
('Семенов И.В.','Санкт-Петербург',700 , '2020-03-29', '2020-04-05'),
('Абрамова К.А.','Москва',700 , '2020-04-06', '2020-04-14'),
('Баранов П.Е.','Новосибирск',450 , '2020-04-18', '2020-05-04'),
('Лебедев Т.К.','Томск',450 , '2020-05-20', '2020-05-31'),
('Семенов И.В.','Санкт-Петербург',700 , '2020-06-01', '2020-06-03'),
('Абрамова К.А.','Санкт-Петербург', 700, '2020-05-28', '2020-06-04'),
('Федорова А.Ю.','Новосибирск',450 , '2020-05-25', '2020-06-04'),
('Колесов С.П.','Новосибирск', 450, '2020-06-03', '2020-06-12'),
('Федорова А.Ю.','Томск', 450, '2020-06-20', '2020-06-26'),
('Абрамова К.А.','Владивосток', 450, '2020-07-02', '2020-07-13'),
('Баранов П.Е.','Воронеж', 450, '2020-07-19', '2020-07-25');


Содержание урока
В этом уроке на каждом шаге нужно реализовать запросы на выборку для таблицы, в которой представлена информация о командировках сотрудников некоторой организации:

Вывести информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а».
Вывести в алфавитном порядке фамилии, имена и отчества тех сотрудников, которые были в командировке в Москве.
Для каждого города посчитать, сколько раз сотрудники в нем были.
Вывести два города, в которых чаще всего были в командировках сотрудники.
Вывести информацию о длительности командировок сотрудников.
Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени.
Вывести информацию о командировках, начало и конец которых относятся к одному месяцу.
Вывести номер месяца и количество командировок, первый день которых приходился на этот месяц.
Вывести сумму суточных  для командировок сотрудников.
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза.
Структура и наполнение таблицы
Таблица trip, в которой представлена информация о командировках сотрудников некоторой организации (фамилия сотрудника, город, куда он ездил, размер суточных, даты первого и последнего дня командировки) :

trip_id	name	city	per_diem	date_first	date_last
INT PRIMARY KEY AUTO_INCREMENT	VARCHAR(30)	VARCHAR(25)	DECIMAL(8,2)	DATЕ	DATE
1	Баранов П.Е.	Москва	700	2020-01-12	2020-01-17
2	Абрамова К.А.	Владивосток	450	2020-01-14	2020-01-27
3	Семенов И.В.	Москва	700	2020-01-23	2020-01-31
4	Ильиных Г.Р.	Владивосток	450	2020-01-12	2020-02-02
5	Колесов С.П.	Москва	700	2020-02-01	2020-02-06
6	Баранов П.Е.	Москва	700	2020-02-14	2020-02-22
7	Абрамова К.А.	Москва	700	2020-02-23	2020-03-01
8	Лебедев Т.К.	Москва	700	2020-03-03	2020-03-06
9	Колесов С.П.	Новосибирск	450	2020-02-27	2020-03-12
10	Семенов И.В.	Санкт-Петербург	700	2020-03-29	2020-04-05
11	Абрамова К.А.	Москва	700	2020-04-06	2020-04-14
12	Баранов П.Е.	Новосибирск	450	2020-04-18	2020-05-04
13	Лебедев Т.К.	Томск	450	2020-05-20	2020-05-31
14	Семенов И.В.	Санкт-Петербург	700	2020-06-01	2020-06-03
15	Абрамова К.А.	Санкт-Петербург	700	2020-05-28	2020-06-04
16	Федорова А.Ю.	Новосибирск	450	2020-05-25	2020-06-04
17	Колесов С.П.	Новосибирск	450	2020-06-03	2020-06-12
18	Федорова А.Ю.	Томск	450	2020-06-20	2020-06-26
19	Абрамова К.А.	Владивосток	450	2020-07-02	2020-07-13
20	Баранов П.Е.	Воронеж	450	2020-07-19	2020-07-25
Пояснение

Тип DATE – позволяет описать дату в формате ГГГГ-ММ-ДД, например, 2020-02-02. При вставке данных в таблицу с помощью INSERT INTO ... VALUES значение даты заключается в кавычки.

Задание
Вывести из таблицы trip информацию о командировках тех сотрудников, фамилия которых заканчивается на букву «а», в отсортированном по убыванию даты последнего дня командировки виде. В результат включить столбцы name, city, per_diem, date_first, date_last.

Результат:

+---------------+-----------------+----------+------------+------------+
| name          | city            | per_diem | date_first | date_last  |
+---------------+-----------------+----------+------------+------------+
| Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
| Федорова А.Ю. | Томск           | 450.00   | 2020-06-20 | 2020-06-26 |
| Абрамова К.А. | Санкт-Петербург | 700.00   | 2020-05-28 | 2020-06-04 |
| Федорова А.Ю. | Новосибирск     | 450.00   | 2020-05-25 | 2020-06-04 |
| Абрамова К.А. | Москва          | 700.00   | 2020-04-06 | 2020-04-14 |
| Абрамова К.А. | Москва          | 700.00   | 2020-02-23 | 2020-03-01 |
| Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
+---------------+-----------------+----------+------------+------------+
Структура и наполнение таблицы trip:



select name, city, per_diem, date_first, date_last 
from trip
where name LIKE "%а %"
order by date_last DESC


Задание
Вывести в алфавитном порядке фамилии и инициалы тех сотрудников, которые были в командировке в Москве.

 Результат:

+---------------+
| name          |
+---------------+
| Абрамова К.А. |
| Баранов П.Е.  |
| Колесов С.П.  |
| Лебедев Т.К.  |
| Семенов И.В.  |
+---------------+
Структура и наполнение таблицы trip:
+---------+---------------+-----------------+----------+------------+------------+
| trip_id | name          | city            | per_diem | date_first | date_last  |
+---------+---------------+-----------------+----------+------------+------------+
| 1       | Баранов П.Е.  | Москва          | 700.00   | 2020-01-12 | 2020-01-17 |
| 2       | Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
| 3       | Семенов И.В.  | Москва          | 700.00   | 2020-01-23 | 2020-01-31 |
| 4       | Ильиных Г.Р.  | Владивосток     | 450.00   | 2020-01-12 | 2020-02-02 |
| 5       | Колесов С.П.  | Москва          | 700.00   | 2020-02-01 | 2020-02-06 |
| 6       | Баранов П.Е.  | Москва          | 700.00   | 2020-02-14 | 2020-02-22 |
                          ...
| 19      | Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
| 20      | Баранов П.Е.  | Воронеж         | 450.00   | 2020-07-19 | 2020-07-25 |
+---------+---------------+-----------------+----------+------------+------------+

select name
from trip
where city LIKE "Москва"
group by name 
order by name

Задание
Для каждого города посчитать, сколько раз сотрудники в нем были.  Информацию вывести в отсортированном в алфавитном порядке по названию городов. Вычисляемый столбец назвать Количество. 

Результат:

+-----------------+------------+
| city            | Количество |
+-----------------+------------+
| Владивосток     | 3          |
| Воронеж         | 1          |
| Москва          | 7          |
| Новосибирск     | 4          |
| Санкт-Петербург | 3          |
| Томск           | 2          |
+-----------------+------------+
Структура и наполнение таблицы trip:
+---------+---------------+-----------------+----------+------------+------------+
| trip_id | name          | city            | per_diem | date_first | date_last  |
+---------+---------------+-----------------+----------+------------+------------+
| 1       | Баранов П.Е.  | Москва          | 700.00   | 2020-01-12 | 2020-01-17 |
| 2       | Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
| 3       | Семенов И.В.  | Москва          | 700.00   | 2020-01-23 | 2020-01-31 |
| 4       | Ильиных Г.Р.  | Владивосток     | 450.00   | 2020-01-12 | 2020-02-02 |
| 5       | Колесов С.П.  | Москва          | 700.00   | 2020-02-01 | 2020-02-06 |
| 6       | Баранов П.Е.  | Москва          | 700.00   | 2020-02-14 | 2020-02-22 |
                          ...
| 19      | Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
| 20      | Баранов П.Е.  | Воронеж         | 450.00   | 2020-07-19 | 2020-07-25 |
+---------+---------------+-----------------+----------+------------+------------+

select city, count(city) AS Количество from trip
group by city
order by 1
Задание
Вывести два города, в которых чаще всего были в командировках сотрудники. Вычисляемый столбец назвать Количество.

Результат:

+-------------+------------+
| city        | Количество |
+-------------+------------+
| Москва      | 7          |
| Новосибирск | 4          |
+-------------+------------+
Пояснение
Структура и наполнение таблицы trip:
Введите SQL запрос

select city, count(city) AS Количество from trip
GROUP BY 1
ORDER BY 2 DESC LIMIT 2

Задание
Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).

Результат:

+---------------+-------------+--------------+
| name          | city        | Длительность |
+---------------+-------------+--------------+
| Ильиных Г.Р.  | Владивосток | 22           |
| Баранов П.Е.  | Новосибирск | 17           |
| Колесов С.П.  | Новосибирск | 15           |
| Абрамова К.А. | Владивосток | 14           |
| Лебедев Т.К.  | Томск       | 12           |
| Абрамова К.А. | Владивосток | 12           |
| Федорова А.Ю. | Новосибирск | 11           |
| Колесов С.П.  | Новосибирск | 10           |
| Федорова А.Ю. | Томск       | 7            |
| Баранов П.Е.  | Воронеж     | 7            |
+---------------+-------------+--------------+
Пояснение
Текст задания (чтобы не прокручивать страницу):

Вывести информацию о командировках во все города кроме Москвы и Санкт-Петербурга (фамилии и инициалы сотрудников, город ,  длительность командировки в днях, при этом первый и последний день относится к периоду командировки). Информацию вывести в упорядоченном по убыванию длительности поездки, а потом по убыванию названий городов (в обратном алфавитном порядке).

Структура и наполнение таблицы trip:

select name, city, datediff(date_last,date_first-1) as Длительность from trip
    where city not in ('Москва','Санкт-Петербург')
        order by Длительность desc, city desc;
		
		
Задание
Вывести информацию о командировках сотрудника(ов), которые были самыми короткими по времени.

Результат:

+--------------+-----------------+------------+------------+
| name         | city            | date_first | date_last  |
+--------------+-----------------+------------+------------+
| Семенов И.В. | Санкт-Петербург | 2020-06-01 | 2020-06-03 |
+--------------+-----------------+------------+------------+
Пояснение
Используйте вложенный запрос, чтобы найти длительность самой короткой командировки. 

Структура и наполнение таблицы trip:
+---------+---------------+-----------------+----------+------------+------------+
| trip_id | name          | city            | per_diem | date_first | date_last  |
+---------+---------------+-----------------+----------+------------+------------+
| 1       | Баранов П.Е.  | Москва          | 700.00   | 2020-01-12 | 2020-01-17 |
| 2       | Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
| 3       | Семенов И.В.  | Москва          | 700.00   | 2020-01-23 | 2020-01-31 |
| 4       | Ильиных Г.Р.  | Владивосток     | 450.00   | 2020-01-12 | 2020-02-02 |
| 5       | Колесов С.П.  | Москва          | 700.00   | 2020-02-01 | 2020-02-06 |
| 6       | Баранов П.Е.  | Москва          | 700.00   | 2020-02-14 | 2020-02-22 |
                          ...
| 19      | Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
| 20      | Баранов П.Е.  | Воронеж         | 450.00   | 2020-07-19 | 2020-07-25 |
+---------+---------------+-----------------+----------+------------+------------+

select name, city, date_first, date_last from trip
where datediff(date_last+1,date_first)=(select MIN(datediff(date_last+1,date_first))from trip)


Задание
Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). Результат отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .

Результат:

+---------------+-----------------+------------+------------+
| name          | city            | date_first | date_last  |
+---------------+-----------------+------------+------------+
| Абрамова К.А. | Владивосток     | 2020-01-14 | 2020-01-27 |
| Абрамова К.А. | Владивосток     | 2020-07-02 | 2020-07-13 |
| Баранов П.Е.  | Воронеж         | 2020-07-19 | 2020-07-25 |
| Абрамова К.А. | Москва          | 2020-04-06 | 2020-04-14 |
| Баранов П.Е.  | Москва          | 2020-01-12 | 2020-01-17 |
| Баранов П.Е.  | Москва          | 2020-02-14 | 2020-02-22 |
| Колесов С.П.  | Москва          | 2020-02-01 | 2020-02-06 |
| Лебедев Т.К.  | Москва          | 2020-03-03 | 2020-03-06 |
| Семенов И.В.  | Москва          | 2020-01-23 | 2020-01-31 |
| Колесов С.П.  | Новосибирск     | 2020-06-03 | 2020-06-12 |
| Семенов И.В.  | Санкт-Петербург | 2020-06-01 | 2020-06-03 |
| Лебедев Т.К.  | Томск           | 2020-05-20 | 2020-05-31 |
| Федорова А.Ю. | Томск           | 2020-06-20 | 2020-06-26 |
+---------------+-----------------+------------+------------+
Пояснение
Для того, чтобы выделить номер месяца из даты используется функция MONTH(дата).

Например, MONTH('2020-04-12') = 4.

Если определяется месяц для  значений столбца date_first, то используется запись MONTH(date_first)

Текст задания (чтобы не прокручивать страницу):

Вывести информацию о командировках, начало и конец которых относятся к одному месяцу (год может быть любой). Результат отсортировать сначала  в алфавитном порядке по названию города, а затем по фамилии сотрудника .

Структура и наполнение таблицы trip:

select name, city, date_first, date_last from trip
where MONTH(date_first)= MONTH(date_date_last)
order by city, name 

Задание
Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

Результат:

+----------+------------+
| Месяц    | Количество |
+----------+------------+
| February | 4          |
| January  | 4          |
| June     | 3          |
| May      | 3          |
| April    | 2          |
| July     | 2          |
| March    | 2          |
+----------+------------+
Пояснение
Для того, чтобы выделить название месяца из даты используется функция MONTHNAME(дата), которая возвращает название месяца на английском языке для указанной даты. Например, MONTHNAME('2020-04-12')='April'.
Если группировка осуществляется по вычисляемому столбцу (в данном случае «вычисляется» название месяца), то после GROUP BYможно указать как вычисляемое выражение, так и имя столбца, заданное с помощью AS. Важно отметить, что последний вариант (указать имя столбца)  нарушает стандарт по порядку выполнения запросов, но иногда может встречаться на реальных платформах.
Текст задания (чтобы не прокручивать страницу):

Вывести название месяца и количество командировок для каждого месяца. Считаем, что командировка относится к некоторому месяцу, если она началась в этом месяце. Информацию вывести сначала в отсортированном по убыванию количества, а потом в алфавитном порядке по названию месяца виде. Название столбцов – Месяц и Количество.

Структура и наполнение таблицы trip:

select MONTHNAME(date_first) AS Месяц, count(MONTHNAME(date_first)) AS Количество from trip
group by Месяц
order by Количество DESC, Месяц

Задание
Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец  per_diem. Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

Результат:

+---------------+-----------------+------------+---------+
| name          | city            | date_first | Сумма   |
+---------------+-----------------+------------+---------+
| Абрамова К.А. | Москва          | 2020-02-23 | 5600.00 |
| Баранов П.Е.  | Москва          | 2020-02-14 | 6300.00 |
| Колесов С.П.  | Новосибирск     | 2020-02-27 | 6750.00 |
| Колесов С.П.  | Москва          | 2020-02-01 | 4200.00 |
| Лебедев Т.К.  | Москва          | 2020-03-03 | 2800.00 |
| Семенов И.В.  | Санкт-Петербург | 2020-03-29 | 5600.00 |
+---------------+-----------------+------------+---------+
Пояснение
Текст задания (чтобы не прокручивать страницу):

 Вывести сумму суточных (произведение количества дней командировки и размера суточных) для командировок, первый день которых пришелся на февраль или март 2020 года. Значение суточных для каждой командировки занесено в столбец  per_diem.  Информацию отсортировать сначала  в алфавитном порядке по фамилиям сотрудников, а затем по убыванию суммы суточных.

Структура и наполнение таблицы trip:
+---------+---------------+-----------------+----------+------------+------------+
| trip_id | name          | city            | per_diem | date_first | date_last  |
+---------+---------------+-----------------+----------+------------+------------+
| 1       | Баранов П.Е.  | Москва          | 700.00   | 2020-01-12 | 2020-01-17 |
| 2       | Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
| 3       | Семенов И.В.  | Москва          | 700.00   | 2020-01-23 | 2020-01-31 |
| 4       | Ильиных Г.Р.  | Владивосток     | 450.00   | 2020-01-12 | 2020-02-02 |
| 5       | Колесов С.П.  | Москва          | 700.00   | 2020-02-01 | 2020-02-06 |
| 6       | Баранов П.Е.  | Москва          | 700.00   | 2020-02-14 | 2020-02-22 |
                          ...
| 19      | Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
| 20      | Баранов П.Е.  | Воронеж         | 450.00   | 2020-07-19 | 2020-07-25 |
+---------+---------------+-----------------+----------+------------+------------+


select name, city, date_first, (datediff(date_last+1,date_first))*per_diem AS Сумма from trip
where MONTHNAME(date_first) IN ('February','March')
order by name, Сумма DESC


Задание
Вывести фамилию с инициалами и общую сумму суточных, полученных за все командировки для тех сотрудников, которые были в командировках больше чем 3 раза, в отсортированном по убыванию сумм суточных виде. Только для этого задания изменена строка таблицы trip:

4	Ильиных Г.Р.	Владивосток	450	2020-01-12	2020-03-02
Результат:

+---------------+----------+
| name          | Сумма    |
+---------------+----------+
| Абрамова К.А. | 29200.00 |
| Баранов П.Е.  | 21300.00 |
+---------------+----------+
Структура и наполнение таблицы trip:
+---------+---------------+-----------------+----------+------------+------------+
| trip_id | name          | city            | per_diem | date_first | date_last  |
+---------+---------------+-----------------+----------+------------+------------+
| 1       | Баранов П.Е.  | Москва          | 700.00   | 2020-01-12 | 2020-01-17 |
| 2       | Абрамова К.А. | Владивосток     | 450.00   | 2020-01-14 | 2020-01-27 |
| 3       | Семенов И.В.  | Москва          | 700.00   | 2020-01-23 | 2020-01-31 |
| 4       | Ильиных Г.Р.  | Владивосток     | 450.00   | 2020-01-12 | 2020-03-02 |
| 5       | Колесов С.П.  | Москва          | 700.00   | 2020-02-01 | 2020-02-06 |
| 6       | Баранов П.Е.  | Москва          | 700.00   | 2020-02-14 | 2020-02-22 |
                          ...
| 19      | Абрамова К.А. | Владивосток     | 450.00   | 2020-07-02 | 2020-07-13 |
| 20      | Баранов П.Е.  | Воронеж         | 450.00   | 2020-07-19 | 2020-07-25 |
+---------+---------------+-----------------+----------+------------+------------+


SELECT name, SUM((DATEDIFF(date_last, date_first) + 1) * per_diem) AS Сумма from trip
GROUP BY name
HAVING count(name) >3
ORDER BY Сумма DESC


Содержание урока
В этом уроке на каждом шаге используется таблица,  в которой представлена информация о начисленных водителям штрафах за нарушения правил дорожного движения (ПДД). С помощью запросов корректировки необходимо выполнить следующие действия:

создать таблицу с информацией о штрафах ;
заполнить ее;
занести сумму штрафа за каждое новое нарушение ПДД;
если водитель на определенной машине совершил повторное нарушение, то сумму его штрафа за данное нарушение нужно увеличить в два раза (часть 1, часть 2) ;
если водитель оплатил свой штраф в течение 20 дней со дня нарушения, то значение его штрафа уменьшить в два раза;
создать новую таблицу,  в которую включить информацию о всех неоплаченных штрафах;
удалить  информацию о нарушениях, совершенных раньше некоторой даты.
На четвертом шаге рассматривается временное именование таблиц (алиасы). 

Структура и наполнение таблиц
В таблице fine  представлена информация о начисленных водителям штрафах за нарушения правил дорожного движения (ПДД) (фамилия водителя, номер машины, описание нарушения, сумма штрафа, дата совершения нарушения и дата оплаты штрафа):

fine_id	name	number_plate	violation	sum_fine	date_violation	date_payment
INT PRIMARY KEY
AUTO_INCREMENT	VARCHAR(30)	VARCHAR(6)	VARCHAR(50)	DECIMAL(8,2)	DATЕ	DATE
1	Баранов П.Е.	Р523ВТ	Превышение скорости
(от 40 до 60)	500.00	2020-01-12	2020-01-17
2	Абрамова К.А.	О111АВ	Проезд на
запрещающий сигнал	1000.00	2020-01-14	2020-02-27
3	Яковлев Г.Р.	Т330ТТ	Превышение скорости
(от 20 до 40)	500.00	2020-01-23	2020-02-23
4	Яковлев Г.Р.	М701АА	Превышение скорости
(от 20 до 40)	 	2020-01-12	 
5	Колесов С.П.	К892АХ	Превышение скорости
(от 20 до 40)	 	2020-02-01	 
6	Баранов П.Е.	Р523ВТ	Превышение скорости
(от 40 до 60)	 	2020-02-14	 
7	Абрамова К.А.	О111АВ	Проезд на
запрещающий сигнал	 	2020-02-23	 
8	Яковлев Г.Р.	Т330ТТ	Проезд на
запрещающий сигнал	 	2020-03-03	 
В таблицу  traffic_violation занесены нарушения ПДД и соответствующие штрафы (в рублях): 

violation_id	violation	sum_fine
INT PRIMARY KEY
AUTO_INCREMENT	VARCHAR(50)	DECIMAL(8,2)
1	Превышение скорости
(от 20 до 40)	500.00
2	Превышение скорости
(от 40 до 60)	1000.00
3	Проезд на
запрещающий сигнал	1000.00

CREATE TABLE fine
(
    fine_id        INT PRIMARY KEY AUTO_INCREMENT,
    name           varchar(30),
    number_plate   varchar(6),
    violation      varchar(50),
    sum_fine       DECIMAL(8, 2),
    date_violation DATE,
    date_payment   DATE
);

INSERT INTO fine (name, number_plate, violation, sum_fine, date_violation, date_payment)
VALUES ('Баранов П.Е.', 'P523BT', 'Превышение скорости(от 40 до 60)', NULL, '2020-02-14 ', NULL),
       ('Абрамова К.А.', 'О111AB', 'Проезд на запрещающий сигнал', NULL, '2020-02-23', NULL),
       ('Яковлев Г.Р.', 'T330TT', 'Проезд на запрещающий сигнал', NULL, '2020-03-03', NULL),
       ('Баранов П.Е.', 'P523BT', 'Превышение скорости(от 40 до 60)', 500.00, '2020-01-12', '2020-01-17'),
       ('Абрамова К.А.', 'О111AB', 'Проезд на запрещающий сигнал', 1000.00, '2020-01-14', '2020-02-27'),
       ('Яковлев Г.Р.', 'T330TT', 'Превышение скорости(от 20 до 40)', 500.00, '2020-01-23', '2020-02-23'),
       ('Яковлев Г.Р.', 'M701AA', 'Превышение скорости(от 20 до 40)', NULL, '2020-01-12', NULL),
       ('Колесов С.П.', 'K892AX', 'Превышение скорости(от 20 до 40)', NULL, '2020-02-01', NULL);



CREATE TABLE traffic_violation
(
    violation_id INT PRIMARY KEY AUTO_INCREMENT,
    violation    varchar(30),
    sum_fine     DECIMAL(8, 2)
);

INSERT INTO traffic_violation (violation, sum_fine)
VALUES ('Превышение скорости(от 20 до 40)', 500),
       ('Превышение скорости(от 40 до 60)', 1000),
       ('Проезд на запрещающий сигнал', 1000);
	   
	   
	   
INSERT INTO fine(name, number_plate, violation, sum_fine, date_violation, date_payment)
VALUES ('Баранов П.Е.', 'Р523ВТ', 'Превышение скорости(от 40 до 60)', null, '2020-02-14 ', null),
        ('Абрамова К.А.', 'О111АВ', 'Проезд на запрещающий сигнал', null, '2020-02-23', null),
        ('Яковлев Г.Р.', 'Т330ТТ', 'Проезд на запрещающий сигнал', null, '2020-03-03', null);	  



Использование временного имени таблицы (алиаса)
Теоретический материал для этого шага подготовлен Михаилом Захаровым . Большое ему спасибо!

Чтобы не писать название таблицы каждый раз, удобно использовать алиасы.

Алиас, это псевдоним, который мы присваивали столбцам после ключевого слова AS(шаг).  Алиасы так же можно использовать и для таблиц. Это становится актуальным, при увеличении числа используемых таблиц, их иногда может быть и 5 и 10 и более. Псевдонимы помогают сделать запрос чище и читабельнее.

Для присваивания псевдонима существует 2 варианта: 

с использованием ключевого слова AS 
FROM fine AS f, traffic_violation AS tv
а так же и без него
FROM fine f, traffic_violation tv
После присвоения таблице алиаса, он используется во всех разделах запроса, в котором алиас задан. Например:

WHERE f.violation = tv.violation
Пример

Для тех, кто уже оплатил штраф, вывести информацию о том, изменялась ли стандартная сумма штрафа.

Запрос:

SELECT  f.name, f.number_plate, f.violation, 
   if(
    f.sum_fine = tv.sum_fine, "Стандартная сумма штрафа", 
    if(
      f.sum_fine < tv.sum_fine, "Уменьшенная сумма штрафа", "Увеличенная сумма штрафа"
    )
  ) AS description               
FROM  fine f, traffic_violation tv
WHERE tv.violation = f.violation and f.sum_fine IS NOT Null;
Результат: 

+---------------+--------------+----------------------------------+--------------------------+
| name          | number_plate | violation                        | description              |
+---------------+--------------+----------------------------------+--------------------------+
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | Уменьшенная сумма штрафа |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | Стандартная сумма штрафа |
| Яковлев Г.Р.  | Т330ТТ       | Превышение скорости(от 20 до 40) | Стандартная сумма штрафа |
+---------------+--------------+----------------------------------+--------------------------+
Задание
Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine.

Таблица traffic_violationсоздана и заполнена.

Результат (для сокращения записи ключевой столбец не показан):

Affected rows: 5
Query result:
+---------------+--------+------------------------------+----------+----------------+--------------+
| name          | number | violation                    | sum_fine | date_violation | date_payment |
|               | _plate |                              |          |                |              |
+---------------+--------+------------------------------+----------+----------------+--------------+
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 500.00   | 2020-01-12     | 2020-01-17   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигнал | 1000.00  | 2020-01-14     | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ | Превышение скорости(от 20... | 500.00   | 2020-01-23     | 2020-02-23   |
| Яковлев Г.Р.  | М701АА | Превышение скорости(от 20... | 500.00   | 2020-01-12     | None         |
| Колесов С.П.  | К892АХ | Превышение скорости(от 20... | 500.00   | 2020-02-01     | None         |
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 1000.00  | 2020-02-14     | None         |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигн...| 1000.00  | 2020-02-23     | None         |
| Яковлев Г.Р.  | Т330ТТ | Проезд на запрещающий сигн...| 1000.00  | 2020-03-03     | None         |
+---------------+--------+------------------------------+----------+----------------+--------------+
Пояснение
Текст задания (чтобы не прокручивать страницу):

Занести в таблицу fine суммы штрафов, которые должен оплатить водитель, в соответствии с данными из таблицы traffic_violation. При этом суммы заносить только в пустые поля столбца  sum_fine.

Таблица traffic_violationсоздана и заполнена.

Структура и наполнение исходной таблицы fine (без ключевого столбца) и таблицыtraffic_violation:
Введите SQL запрос

UPDATE fine f, traffic_violation tv
SET f.sum_fine = tv.sum_fine
WHERE f.violation = tv.violation and f.sum_fine  IS null;
select name, number_plate, violation, sum_fine, date_violation, date_payment from fine


Задание
Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.

Пояснение
Скорректированная на предыдущих шагах таблица fine имеет вид (без ключевого столбца):

+---------------+--------------+----------------------------------+----------+------------------+--------------+
| name          | number_plate | violation                        | sum_fine | date_violation   | date_payment |
+---------------+--------------+----------------------------------+----------+------------------+--------------+
| Баранов П.Е.  | P523BT       | Превышение скорости(от 40 до 60) | 500.00   | 2020-01-12       | 2020-01-17   |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | 1000.00  | 2020-01-14       | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ       | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-23       | 2020-02-23   |
| Яковлев Г.Р.  | М701АА       | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-12       | None         |
| Колесов С.П.  | К892АХ       | Превышение скорости(от 20 до 40) | 500.00   | 2020-02-01       | None         |
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | 1000.00  | 2020-02-14       | None         |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | 1000.00  | 2020-02-23       | None         |
| Яковлев Г.Р.  | Т330ТТ       | Проезд на запрещающий сигнал     | 1000.00  | 2020-03-03       | None         |
+---------------+--------------+----------------------------------+----------+------------------+--------------+
Под увеличение  штрафа в два раза подходит водитель «Абрамова К.А.», который на машине с государственным номером «О111АВ» совершил повторное нарушение «Проезд на запрещающий сигнал», а также водитель  «Баранов П.Е.» , который на машине с номером  «Р523ВТ» дважды совершил нарушение «Превышение скорости(от 40 до 60) ».

Результат:

+---------------+--------------+----------------------------------+
| name          | number_plate | violation                        |
+---------------+--------------+----------------------------------+
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     |
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) |
+---------------+--------------+----------------------------------+
Текст задания (чтобы не прокручивать страницу):

Вывести фамилию, номер машины и нарушение только для тех водителей, которые на одной машине нарушили одно и то же правило   два и более раз. При этом учитывать все нарушения, независимо от того оплачены они или нет. Информацию отсортировать в алфавитном порядке, сначала по фамилии водителя, потом по номеру машины и, наконец, по нарушению.

Структура и наполнение таблицы fine (без ключевого столбца) перед выполнением этого шага:



select name, number_plate, violation from fine
group by name, number_plate, violation
HAVING count(number_plate) > 1
order by name, number_plate, violation;

Задание
В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. 

Пояснение
Для всех  нарушений, по которым штраф еще не оплачен, (тех, у которых date_payment имеет пустое значение Null), необходимо проверить, является ли данное нарушение для водителя и машины повторным, если да –  увеличить штраф в два раза.
Если водитель совершил нарушение на другой машине, ему увеличивать штраф не нужно.
Если несколько повторных нарушений не оплачены, то штраф увеличить для всех.
Этот запрос реализован на предыдущем шаге.
При реализации можно использовать вложенный запрос как отдельную таблицу, записанную после ключевого слова UPDATE, при этом вложенному запросу необходимо присвоить имя, например query_in:

UPDATE fine, 
    (
     SELECT ...
    ) query_in
SET ...
WHERE ...
Другим способом решения является использование двух запросов: сначала создать временную таблицу, например query_in, в которую включить информацию о тех штрафах, сумму которых нужно увеличить в два раза, а затем уже обновлять информацию в таблице fine:

CREATE TABLE query_in ...;

UPDATE fine, query_in
SET ...
WHERE ...;
После ключевого слова WHERE  указывается условие, при котором нужно обновлять данные. В нашем случае  данные обновляются, если и фамилия, и государственный номер, и нарушение совпадают в таблице fine и в результирующей таблице запроса query_in. Например, для связи по фамилии используется запись fine.name = query_in.name. Также в условии нужно учесть, что данные обновляются только для тех записей, у которых в столбце date_payment пусто.

Результат:

Affected rows: 2

Query result:
+---------------+--------------+----------------------------------+----------+------------------+--------------+
| name          | number_plate | violation                        | sum_fine | date_violation   | date_payment |
+---------------+--------------+----------------------------------+----------+------------------+--------------+
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | 500.00   | 2020-01-12       | 2020-01-17   |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | 1000.00  | 2020-01-14       | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ       | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-23       | 2020-02-23   |
| Яковлев Г.Р.  | М701АА       | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-12       | None         |
| Колесов С.П.  | К892АХ       | Превышение скорости(от 20 до 40) | 500.00   | 2020-02-01       | None         |
| Баранов П.Е.  | Р523ВТ       | Превышение скорости(от 40 до 60) | 2000.00  | 2020-02-14       | None         |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | 2000.00  | 2020-02-23       | None         |
| Яковлев Г.Р.  | Т330ТТ       | Проезд на запрещающий сигнал     | 1000.00  | 2020-03-03       | None         |
+---------------+--------------+----------------------------------+----------+------------------+--------------+
Важно. Если в запросе используется несколько таблиц или запросов, включающих одинаковые поля, то применяется полное имя столбца, включающего название таблицы через символ «.». Например,  fine.name  и  query_in.name.

Текст задания (чтобы не прокручивать страницу):

В таблице fine увеличить в два раза сумму неоплаченных штрафов для отобранных на предыдущем шаге записей. При этом считать, что увеличивать сумму нужно только для неоплаченных штрафов.

Структура и наполнение таблицы fine (без ключевого столбца) перед выполнением этого шага:

CREATE  TABLE query_in (select name, number_plate, violation from fine
    group by name, number_plate, violation
    HAVING count(number_plate) > 1
    order by name, number_plate, violation);
update fine, query_in
SET sum_fine = sum_fine *2

WHERE fine.name = query_in.name and date_payment is null;
select * from fine

Задание
Водители оплачивают свои штрафы. В таблице payment занесены даты их оплаты:

payment_id	name	number_plate	violation	date_violation	date_payment
1	Яковлев Г.Р.	М701АА	Превышение скорости
(от 20 до 40)	2020-01-12	2020-01-22
2	Баранов П.Е.	Р523ВТ	Превышение скорости
(от 40 до 60)	2020-02-14	2020-03-06
3	Яковлев Г.Р.	Т330ТТ	Проезд на
запрещающий сигнал	2020-03-03	2020-03-23
Необходимо:

в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
уменьшить начисленный штраф в таблице fine в два раза  (только для новых штрафов, дата оплаты которых занесена в payment) , если оплата произведена не позднее 20 дней со дня нарушения.
Результат (без ключевого столбца):

Affected rows: 3
Query result:
+---------------+--------+----------------------------------+----------+---------------------------+
| name          | number_| violation                        | sum_fine | date_      | date_payment |
|               |  plate |                                  |          | violation  |              |
+---------------+--------+----------------------------------+----------+------------+--------------+
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40 до 60) | 500.00   | 2020-01-12 | 2020-01-17   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигнал     | 1000.00  | 2020-01-14 | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ | Превышение скорости(от 20 до 40) | 500.00   | 2020-01-23 | 2020-02-23   |
| Яковлев Г.Р.  | М701АА | Превышение скорости(от 20 до 40) | 250.00   | 2020-01-12 | 2020-01-22   |
| Колесов С.П.  | К892АХ | Превышение скорости(от 20 до 40) | 500.00   | 2020-02-01 | None         |
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40 до 60) | 2000.00  | 2020-02-14 | 2020-03-06   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигнал     | 2000.00  | 2020-02-23 | None         |
| Яковлев Г.Р.  | Т330ТТ | Проезд на запрещающий сигнал     | 500.00   | 2020-03-03 | 2020-03-23   |
+---------------+--------+----------------------------------+----------+------------+--------------+
Пояснение
1. Для уменьшения суммы штрафа в два раза в зависимости от условия можно  использовать функцию if().  Синтаксис раздела SET при использовании функции if() следующий:

SET столбец = IF(условие, выражение_1, выражение_2)
Выполняется этот оператор так:

сначала вычисляется условие;
если условие ИСТИНА, то вычисляется выражение_1, в противном случае (если условие ЛОЖНО) вычисляется выражение_2;
в столбец заносится результат выполнения функции (либо значение выражения_1, либо значение выражения_2 в зависимости от условия).
2. Количество дней между датой нарушения и датой оплаты считается по формуле:

количество_дней = дата_оплаты - дата_нарушения 

Текст задания (чтобы не прокручивать страницу):

Необходимо:

в таблицу fine занести дату оплаты соответствующего штрафа из таблицы payment; 
уменьшить начисленный штраф в таблице fine в два раза  (только для новых штрафов, дата оплаты которых занесена в payment) , если оплата произведена не позднее 20 дней со дня нарушения.
Пояснение к решению
Структура и наполнение таблицы fine (без ключевого столбца) перед выполнением этого шага:

UPDATE 
    fine, payment
SET 
    fine.date_payment = payment.date_payment,
    fine.sum_fine = IF(DATEDIFF(payment.date_payment, fine.date_violation) <= 20, fine.sum_fine/2, fine.sum_fine)
WHERE
    fine.number_plate = payment.number_plate and
    fine.violation = payment.violation and
    fine.name = payment.name and
    fine.date_payment is null;


select  number_plate, violation, sum_fine, date_violation, date_payment from fine;

Задание
Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

Результат:

Affected rows: 2
Query result:
+---------------+--------------+----------------------------------+----------+------------------+
| name          | number_plate | violation                        | sum_fine | date_violation   |
+---------------+--------------+----------------------------------+----------+------------------+
| Колесов С.П.  | К892АХ       | Превышение скорости(от 20 до 40) | 500.00   | 2020-02-01       |
| Абрамова К.А. | О111АВ       | Проезд на запрещающий сигнал     | 2000.00  | 2020-02-23       |
+---------------+--------------+----------------------------------+----------+------------------+
Пояснение
Важно. На этом шаге необходимо создать таблицу на основе запроса! Не нужно одним запросом создавать таблицу, а вторым в нее добавлять строки.

Текст задания (чтобы не прокручивать страницу):

Создать новую таблицу back_payment, куда внести информацию о неоплаченных штрафах (Фамилию и инициалы водителя, номер машины, нарушение, сумму штрафа  и  дату нарушения) из таблицы fine.

Структура и наполнение таблицы fine (без ключевого столбца) перед выполнением этого шага:
+---------------+--------+------------------------------+----------+----------------+--------------+
| name          | number | violation                    | sum_fine | date_violation | date_payment |
|               | _plate |                              |          |                |              |
+---------------+--------+------------------------------+----------+----------------+--------------+
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 500.00   | 2020-01-12     | 2020-01-17   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигнал | 1000.00  | 2020-01-14     | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ | Превышение скорости(от 20... | 500.00   | 2020-01-23     | 2020-02-23   |
| Яковлев Г.Р.  | М701АА | Превышение скорости(от 20... | 250.00   | 2020-01-12     | 2020-01-22   |
| Колесов С.П.  | К892АХ | Превышение скорости(от 20... | 500.00   | 2020-02-01     | None         |
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 2000.00  | 2020-02-14     | 2020-03-05   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигн...| 2000.00  | 2020-02-23     | None         |
| Яковлев Г.Р.  | Т330ТТ | Проезд на запрещающий сигн...| 500.00   | 2020-03-03     | 2020-03-22   |
+---------------+--------+------------------------------+----------+----------------+--------------+


CREATE TABLE back_payment AS
SELECT  name, number_plate, violation, sum_fine, date_violation  
   
FROM fine
WHERE date_payment is null;

SELECT * FROM back_payment;



Задание
Удалить из таблицы fine информацию о нарушениях, совершенных раньше 1 февраля 2020 года. 

Результат:

Affected rows: 4

Query result (это выборка из таблицы fine после удаления записей):
+---------------+--------+------------------------------+----------+----------------+--------------+
| name          | number | violation                    | sum_fine | date_violation | date_payment |
|               | _plate |                              |          |                |              |
+---------------+--------+------------------------------+----------+----------------+--------------+
| Колесов С.П.  | К892АХ | Превышение скорости(от 20... | 500.00   | 2020-02-01     | None         |
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 2000.00  | 2020-02-14     | 2020-03-05   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигн...| 2000.00  | 2020-02-23     | None         |
| Яковлев Г.Р.  | Т330ТТ | Проезд на запрещающий сигн...| 500.00   | 2020-03-03     | 2020-03-22   |
+---------------+--------+------------------------------+----------+----------------+--------------+
Структура и наполнение таблицы fine (без ключевого столбца) перед выполнением этого шага:
+---------------+--------+------------------------------+----------+----------------+--------------+
| name          | number | violation                    | sum_fine | date_violation | date_payment |
|               | _plate |                              |          |                |              |
+---------------+--------+------------------------------+----------+----------------+--------------+
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 500.00   | 2020-01-12     | 2020-01-17   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигнал | 1000.00  | 2020-01-14     | 2020-02-27   |
| Яковлев Г.Р.  | Т330ТТ | Превышение скорости(от 20... | 500.00   | 2020-01-23     | 2020-02-23   |
| Яковлев Г.Р.  | М701АА | Превышение скорости(от 20... | 250.00   | 2020-01-12     | 2020-01-22   |
| Колесов С.П.  | К892АХ | Превышение скорости(от 20... | 500.00   | 2020-02-01     | None         |
| Баранов П.Е.  | Р523ВТ | Превышение скорости(от 40... | 2000.00  | 2020-02-14     | 2020-03-05   |
| Абрамова К.А. | О111АВ | Проезд на запрещающий сигн...| 2000.00  | 2020-02-23     | None         |
| Яковлев Г.Р.  | Т330ТТ | Проезд на запрещающий сигн...| 500.00   | 2020-03-03     | 2020-03-22   |
+---------------+--------+------------------------------+----------+----------------+--------------+


delete from fine
where date_violation < '2020-02-01'




Действия при удалении записи главной таблицы
С помощью выражения ON DELETE  можно установить действия, которые выполняются для записей подчиненной таблицы при удалении связанной строки из главной таблицы. При удалении можно установить следующие опции:

CASCADE: автоматически удаляет строки из зависимой таблицы при удалении  связанных строк в главной таблице.
SET NULL: при удалении  связанной строки из главной таблицы устанавливает для столбца внешнего ключа значение NULL. (В этом случае столбец внешнего ключа должен поддерживать установку NULL).
SET DEFAULT похоже на SET NULL за тем исключением, что значение  внешнего ключа устанавливается не в NULL, а в значение по умолчанию для данного столбца.
RESTRICT: отклоняет удаление строк в главной таблице при наличии связанных строк в зависимой таблице.
Важно! Если для столбца установлена опция SET NULL, то при его описании нельзя задать ограничение на пустое значение.

Пример

Будем считать, что при удалении автора из таблицы author, необходимо удалить все записи о книгах из таблицы book, написанные этим автором. Данное действие необходимо прописать при создании таблицы.

Запрос:

CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE
);
Задание
Создать таблицу book той же структуры, что и на предыдущем шаге. Будем считать, что при удалении автора из таблицы author, должны удаляться все записи о книгах из таблицы book, написанные этим автором. А при удалении жанра из таблицы genre для соответствующей записи book установить значение Null в столбце genre_id. 

Результат:

Affected rows: 0


CREATE TABLE book (
    book_id INT PRIMARY KEY AUTO_INCREMENT, 
    title VARCHAR(50), 
    author_id INT NOT NULL, 
    genre_id INT,
    price DECIMAL(8,2), 
    amount INT, 
    FOREIGN KEY (author_id)  REFERENCES author (author_id) ON DELETE CASCADE,
    FOREIGN KEY (genre_id)  REFERENCES genre (genre_id) ON DELETE SET NULL
);

Задание
Добавьте три последние записи (с ключевыми значениями 6, 7, 8) в таблицу book, первые 5 записей уже добавлены:

book_id	title	author_id	genre_id	price	amount
1	Мастер и Маргарита	1	1	670.99	3
2	Белая гвардия	1	1	540.50	5
3	Идиот	2	1	460.00	10
4	Братья Карамазовы	2	1	799.01	3
5	Игрок	2	1	480.50	10
6	Стихотворения и поэмы	3	2	650.00	15
7	Черный человек	3	2	570.20	6
8	Лирика	4	2	518.99	2
Логическая схема базы данных:



Результат : 

Affected rows: 1
Affected rows: 1
Affected rows: 1
Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 5      |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+



INSERT INTO book (title, author_id, genre_id, price, amount) VALUES ('Стихотворения и поэмы',3, 2, 650.00, 15);
INSERT INTO book (title, author_id, genre_id, price, amount) VALUES ('Черный человек',3,2,570.20,6);
INSERT INTO book (title, author_id, genre_id, price, amount) VALUES ('Лирика',4,2,518.99,2);


Содержание урока
В запросах SQL могут участвовать несколько таблиц базы данных. При этом необходимо указать как эти таблицы соединены между собой. 

Операция соединения JOIN предназначена для обеспечения выборки данных из двух таблиц и включения этих данных в один результирующий набор. При необходимости соединения не двух, а нескольких таблиц, операция соединения применяется несколько раз (последовательно).

Операторы соединения входят в раздел FROM SQL запросов.

В данном уроке будут созданы запросы:

для двух таблиц, внутреннее соединение INNER JOIN;
для двух таблиц, внешние соединения LEFT JOIN и RIGHT JOIN;
для двух таблиц, перекрестное соединение CROSS JOIN;
выборки данных из нескольких таблиц;
выборки данных из нескольких таблиц с группировкой;
выборки данных с применением вложенных запросов;
вложенные запросы в операторах соединения,
операторы соединения, использование USING.
Структура и наполнение таблиц
Концептуальная схема базы данных: 

Логическая схема базы данных:

Таблица author(создание, заполнение):

author_id	name_author
1	Булгаков М.А.
2	Достоевский Ф.М.
3	Есенин С.А.
4	Пастернак Б.Л.
5	Лермонтов М.Ю.
Таблица genre(создание, заполнение, рассмотрено в качестве примеров):

genre_id	name_genre
1	Роман
2	Поэзия
3	Приключения
Таблица book (создание, заполнение):

book_id	title	author_id	genre_id	price	amount
1	Мастер и Маргарита	1	1	670.99	3
2	Белая гвардия	1	1	540.50	5
3	Идиот	2	1	460.00	10
4	Братья Карамазовы	2	1	799.01	3
5	Игрок	2	1	480.50	10
6	Стихотворения и поэмы	3	2	650.00	15
7	Черный человек	3	2	570.20	6
8	Лирика	4	2	518.99	2


Соединение INNER JOIN
Оператор внутреннего соединения INNER JOIN соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным.

SELECT
 ...
FROM
    таблица_1 INNER JOIN  таблица_2
    ON условие
...
Результат запроса формируется так:

каждая строка одной таблицы сопоставляется с каждой строкой второй таблицы;
для полученной «соединённой» строки проверяется условие соединения;
если условие истинно, в таблицу результата добавляется соответствующая «соединённая» строка;
Пример

Вывести название книг и их авторов.

Запрос:

SELECT title, name_author
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
Поскольку поля author_id в таблицах book и author называются одинаково, необходимо в запросах указывать полную ссылку на них (book.author_id
 и author.author_id).

Результат:

+-----------------------+------------------+
| title                 | name_author      |
+-----------------------+------------------+
| Мастер и Маргарита    | Булгаков М.А.    |
| Белая гвардия         | Булгаков М.А.    |
| Идиот                 | Достоевский Ф.М. |
| Братья Карамазовы     | Достоевский Ф.М. |
| Игрок                 | Достоевский Ф.М. |
| Стихотворения и поэмы | Есенин С.А.      |
| Черный человек        | Есенин С.А.      |
| Лирика                | Пастернак Б.Л.   |
+-----------------------+------------------+
В данном запросе осуществляется соединение главной таблицы author и зависимой таблицы book по ключевому столбцу author.author_id и внешнему 
ключу book.author_id. При этом в результирующую таблицу запроса включаются все строки, в которых значения этих столбцов совпадают. Другими 
словами строки зависимой таблицы book дополняются фамилией и инициалами авторов из таблицы author.

Задание
Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.

Логическая схема базы данных:



Результат:

+-----------------------+------------+--------+
| title                 | name_genre | price  |
+-----------------------+------------+--------+
| Стихотворения и поэмы | Поэзия     | 650.00 |
| Игрок                 | Роман      | 480.50 |
| Идиот                 | Роман      | 460.00 |
+-----------------------+------------+--------+
Текст задания (чтобы не прокручивать страницу):

Вывести название, жанр и цену тех книг, количество которых больше 8, в отсортированном по убыванию цены виде.



SELECT title, name_genre, price
FROM 
    genre INNER JOIN book
    ON /*author.author_id = book.author_id and*/
    genre.genre_id = book.genre_id
    and amount >8
    order by price DESC;
	
Внешнее соединение LEFT и RIGHT OUTER JOIN
Оператор внешнего соединения LEFT OUTER JOIN  (можно использовать LEFT JOIN) соединяет две таблицы. Порядок таблиц для оператора важен, 
поскольку оператор не является симметричным.

SELECT
 ...
FROM
    таблица_1 LEFT JOIN  таблица_2
    ON условие
...
Результат запроса формируется так:

в результат включается внутреннее соединение (INNER JOIN) первой и второй таблицы в соответствии с условием;
затем в результат добавляются те записи первой таблицы, которые не вошли во внутреннее соединение на шаге 1, для таких записей 
соответствующие поля второй таблицы заполняются значениями NULL.
Соединение RIGHT JOIN действует аналогично, только в пункте 2 первая таблица меняется на вторую и наоборот.

Пример

Вывести название всех книг каждого автора, если книг некоторых авторов в данный момент нет на складе – вместо названия книги указать Null.

Запрос:

SELECT name_author, title 
FROM author LEFT JOIN book
     ON author.author_id = book.author_id
ORDER BY name_author;     
Результат:

+------------------+-----------------------+
| name_author      | title                 |
+------------------+-----------------------+
| Булгаков М.А.    | Мастер и Маргарита    |
| Булгаков М.А.    | Белая гвардия         |
| Достоевский Ф.М. | Игрок                 |
| Достоевский Ф.М. | Идиот                 |
| Достоевский Ф.М. | Братья Карамазовы     |
| Есенин С.А.      | Стихотворения и поэмы |
| Есенин С.А.      | Черный человек        |
| Лермонтов М.Ю.   | None                  |
| Пастернак Б.Л.   | Лирика                |
+------------------+-----------------------+
Так как в таблице book нет книг Лермонтова, напротив этой фамилии стоит Null (None).

Задание
Вывести все жанры, которые не представлены в книгах на складе.

Логическая схема базы данных:



Результат:

+-------------+
| name_genre  |
+-------------+
| Приключения |
+-------------+
Пояснение
При использовании внешнего соединения названия книг и другие столбцы таблицы book для жанра тех книг, которого нет на складе, будут 
содержать значение Null.

Текст задания (чтобы не прокручивать страницу):

Вывести все жанры, которые не представлены в книгах на складе.	
	
	
SELECT name_genre
FROM genre LEFT JOIN book
     ON  book.genre_id = genre.genre_id 
where    title is null;





Перекрестное соединение CROSS JOIN
Оператор перекрёстного соединения, или декартова произведения CROSS JOIN (в запросе вместо ключевых слов можно поставить запятую между 
таблицами) соединяет две таблицы. Порядок таблиц для оператора неважен, поскольку оператор является симметричным. Его структура:

SELECT
 ...
FROM
    таблица_1 CROSS JOIN  таблица_2
...
или

SELECT
 ...
FROM
    таблица_1, таблица_2
...
Результат запроса формируется так: каждая строка одной таблицы соединяется с каждой строкой другой таблицы, формируя  в результате
 все возможные сочетания строк двух таблиц.

Например, запрос:

SELECT name_author, name_genre
FROM 
    author, genre;
каждому автору из таблицы author поставит в соответствие все возможные жанры из таблицы genre:

+------------------+-------------+
| name_author      | name_genre  |
+------------------+-------------+
| Булгаков М.А.    | Роман       |
| Булгаков М.А.    | Поэзия      |
| Булгаков М.А.    | Приключения |
| Достоевский Ф.М. | Роман       |
| Достоевский Ф.М. | Поэзия      |
| Достоевский Ф.М. | Приключения |
| Есенин С.А.      | Роман       |
| Есенин С.А.      | Поэзия      |
| Есенин С.А.      | Приключения |
| Пастернак Б.Л.   | Роман       |
| Пастернак Б.Л.   | Поэзия      |
| Пастернак Б.Л.   | Приключения |
| Лермонтов М.Ю.   | Роман       |
| Лермонтов М.Ю.   | Поэзия      |
| Лермонтов М.Ю.   | Приключения |
+------------------+-------------+
Задание
Есть список городов, хранящийся в таблице city:

city_id	name_city
1	Москва
2	Санкт-Петербург
3	Владивосток
Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. 
Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав
 сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

Структура таблицы:



Результат (даты при каждом запуске получаются разными, и не должны совпадать с приведенными значениями):

+-----------------+------------------+------------+
| name_city       | name_author      | Дата       |
+-----------------+------------------+------------+
| Владивосток     | Достоевский Ф.М. | 2020-12-04 |
| Владивосток     | Лермонтов М.Ю.   | 2020-10-21 |
| Владивосток     | Пастернак Б.Л.   | 2020-08-23 |
| Владивосток     | Есенин С.А.      | 2020-08-14 |
| Владивосток     | Булгаков М.А.    | 2020-01-08 |
| Москва          | Лермонтов М.Ю.   | 2020-09-30 |
| Москва          | Достоевский Ф.М. | 2020-07-21 |
| Москва          | Есенин С.А.      | 2020-06-23 |
| Москва          | Булгаков М.А.    | 2020-05-28 |
| Москва          | Пастернак Б.Л.   | 2020-04-08 |
| Санкт-Петербург | Булгаков М.А.    | 2020-11-05 |
| Санкт-Петербург | Лермонтов М.Ю.   | 2020-10-22 |
| Санкт-Петербург | Достоевский Ф.М. | 2020-09-19 |
| Санкт-Петербург | Есенин С.А.      | 2020-08-11 |
| Санкт-Петербург | Пастернак Б.Л.   | 2020-06-28 |
+-----------------+------------------+------------+
Пояснение
Текст задания (чтобы не прокручивать страницу):

 Есть список городов, хранящийся в таблице city:

city_id	name_city
1	Москва
2	Санкт-Петербург
3	Владивосток
Необходимо в каждом городе провести выставку книг каждого автора в течение 2020 года. Дату проведения выставки выбрать случайным образом. 
Создать запрос, который выведет город, автора и дату проведения выставки. Последний столбец назвать Дата. Информацию вывести, отсортировав 
сначала в алфавитном порядке по названиям городов, а потом по убыванию дат проведения выставок.

select name_city, name_author,DATE_ADD('2020-01-01', INTERVAL FLOOR(RAND(1) * 365) DAY) as Дата  from city CROSS JOIN author
order by name_city, Дата DESC



Запросы на выборку из нескольких таблиц
Запрос на выборку может выбирать данные из двух и более таблиц базы данных. При этом таблицы должны быть логически связаны между собой. Для каждой пары таблиц, включаемых в запрос, необходимо указать свой оператор соединения. Наиболее распространенным является внутреннее соединение INNER JOIN, поэтому в примерах будем использовать его.

Пусть таблицы связаны между собой следующим образом:



тогда запрос на выборку для этих таблиц будет иметь вид:

SELECT
 ...
FROM
    first INNER JOIN  second
    ON first.first_id = second.first_id
        INNER JOIN  third
         ON second.second_id = third.second_id
...
Если же таблицы связаны так:



то запрос на выборку выглядит следующим образом:

SELECT
 ...
FROM
    first INNER JOIN  third
    ON first.first_id = third.first_id
        INNER JOIN second
        ON third.second_id = second.second_id 
...
В этом случае рекомендуется соединение таблиц записывать последовательно, «по кругу»: first → third → second.

Пример

Вывести информацию о тех книгах, их авторах и жанрах, цена которых принадлежит интервалу от 500  до 700 рублей  включительно.

Запрос:

SELECT title, name_author, name_genre, price, amount
FROM
    author INNER JOIN  book
    ON author.author_id = book.author_id
        INNER JOIN genre
        ON genre.genre_id = book.genre_id
WHERE price BETWEEN 500 AND 700;
Результат:

+-----------------------+----------------+------------+--------+--------+
| title                 | name_author    | name_genre | price  | amount |
+-----------------------+----------------+------------+--------+--------+
| Мастер и Маргарита    | Булгаков М.А.  | Роман      | 670.99 | 3      |
| Белая гвардия         | Булгаков М.А.  | Роман      | 540.50 | 5      |
| Стихотворения и поэмы | Есенин С.А.    | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.    | Поэзия     | 570.20 | 6      |
| Лирика                | Пастернак Б.Л. | Поэзия     | 518.99 | 2      |
+-----------------------+----------------+------------+--------+--------+
Задание
 Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.

Логическая схема базы данных:



Результат:

+------------+--------------------+------------------+
| name_genre | title              | name_author      |
+------------+--------------------+------------------+
| Роман      | Белая гвардия      | Булгаков М.А.    |
| Роман      | Братья Карамазовы  | Достоевский Ф.М. |
| Роман      | Игрок              | Достоевский Ф.М. |
| Роман      | Идиот              | Достоевский Ф.М. |
| Роман      | Мастер и Маргарита | Булгаков М.А.    |
+------------+--------------------+------------------+
Текст задания (чтобы не прокручивать страницу):

 Вывести информацию о книгах (жанр, книга, автор), относящихся к жанру, включающему слово «роман» в отсортированном по названиям книг виде.
 
 
 SELECT name_genre, title, name_author
FROM
    author INNER JOIN  book
    ON author.author_id = book.author_id
        INNER JOIN genre
        ON genre.genre_id = book.genre_id
WHERE name_genre LIKE "Роман"
order by title;


Запросы для нескольких таблиц с группировкой
В запросах с групповыми функциями могут использоваться несколько таблиц, между которыми используются различные типы соединений.

Пример

Вывести количество различных книг каждого автора. Информацию отсортировать в алфавитном порядке по фамилиям  авторов.

Запрос:

SELECT name_author, count(title) AS Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;    
Результат

+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
При использовании соединения INNER JOIN мы не можем узнать, что книг Лермонтова на складе нет, но предполагается, что они могут быть.  
Чтобы автор Лермонтов был включен в результат, нужно изменить соединение таблиц.

Запрос:

SELECT name_author, count(title) AS Количество
FROM 
    author LEFT JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
ORDER BY name_author;   
Результат:

+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 2          |
| Достоевский Ф.М. | 3          |
| Есенин С.А.      | 2          |
| Лермонтов М.Ю.   | 0          |
| Пастернак Б.Л.   | 1          |
+------------------+------------+
Задание
Посчитать количество экземпляров  книг каждого автора на складе.  Вывести тех авторов,  количество книг которых меньше 10, в 
отсортированном по возрастанию количества виде. Последний столбец назвать Количество.

Логическая схема базы данных:



Результат:

+----------------+------------+
| name_author    | Количество |
+----------------+------------+
| Лермонтов М.Ю. | None       |
| Пастернак Б.Л. | 2          |
| Булгаков М.А.  | 8          |
+----------------+------------+
Пояснение
Текст задания (чтобы не прокручивать страницу):

Посчитать количество экземпляров  книг каждого автора на складе.  Вывести тех авторов,  количество книг которых меньше 10, в 
отсортированном по возрастанию количества виде. Последний столбец назвать Количество.


SELECT name_author, SUM(b.amount) AS Количество
FROM author a
LEFT JOIN book b ON a.author_id = b.author_id
GROUP BY name_author
HAVING IFNULL(SUM(b.amount), 0) < 10
ORDER BY Количество



Запросы для нескольких таблиц со вложенными запросами
В запросах, построенных на нескольких таблицах, можно использовать вложенные запросы. Вложенный запрос может быть включен:  после ключевого слова SELECT,  после FROM и в условие отбора после WHERE (HAVING).

Пример

Вывести авторов, общее количество книг которых на складе максимально.

Это достаточно сложный запрос, поэтому будем решать его по шагам (реализуя каждый запрос по отдельности), а потом объединим все запросы в один.

Шаг 1. Найдем суммарное количество книг на складе по каждому автору. Поскольку фамилии автора в этой таблице нет, то группировку будем осуществлять по author_id.

Запрос:

SELECT author_id, SUM(amount) AS sum_amount FROM book GROUP BY author_id
Результат:

+-----------+------------+
| author_id | sum_amount |
+-----------+------------+
| 1         | 8          |
| 2         | 23         |
| 3         | 21         |
| 4         | 2          |
+-----------+------------+
Шаг 2. В результирующей таблице предыдущего запроса необходимо найти максимальное значение, то есть 23. Для этого запросу, созданному на шаге 1, необходимо присвоить имя (например, query_in) и использовать его в качестве таблицы-источника после FROM. Затем уже находить максимум по столбцу sum_amount.

Запрос:  

SELECT MAX(sum_amount) AS max_sum_amount
FROM 
    (
     SELECT author_id, SUM(amount) AS sum_amount 
     FROM book 
     GROUP BY author_id
    ) query_in
Результат:

+----------------+
| max_sum_amount |
+----------------+
| 23             |
+----------------+
Шаг 3. Выведем фамилию автора и общее количество книг для него.

Запрос:  

SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
Результат:

+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Булгаков М.А.    | 8          |
| Достоевский Ф.М. | 23         |
| Есенин С.А.      | 21         |
| Пастернак Б.Л.   | 2          |
+------------------+------------+
Шаг 4.  Включим запрос с шага 2 в условие отбора запроса с шага 3. И получим всех авторов, общее количество книг которых максимально.

 Запрос:  

SELECT name_author, SUM(amount) as Количество
FROM 
    author INNER JOIN book
    on author.author_id = book.author_id
GROUP BY name_author
HAVING SUM(amount) = 
     (/* вычисляем максимальное из общего количества книг каждого автора */
      SELECT MAX(sum_amount) AS max_sum_amount
      FROM 
          (/* считаем количество книг каждого автора */
            SELECT author_id, SUM(amount) AS sum_amount 
            FROM book GROUP BY author_id
          ) query_in
      );
Результат:

+------------------+------------+
| name_author      | Количество |
+------------------+------------+
| Достоевский Ф.М. | 23         |
+------------------+------------+
Задание
Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные, что у каждого 
автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу book. Пусть у нас  книга Есенина «Черный человек» относится
 к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (эти изменения в таблицы уже внесены).

Логическая схема базы данных:



Результат:

+------------------+
| name_author      |
+------------------+
| Достоевский Ф.М. |
| Пастернак Б.Л.   |
+------------------+
Текст задания (чтобы не прокручивать страницу):

 Вывести в алфавитном порядке всех авторов, которые пишут только в одном жанре. Поскольку у нас в таблицах так занесены данные, что у каждого 
 автора книги только в одном жанре,  для этого запроса внесем изменения в таблицу book. Пусть у нас  книга Есенина «Черный человек» относится 
 к жанру «Роман», а книга Булгакова «Белая гвардия» к «Приключениям» (эти изменения в таблицы уже внесены).
 
 select name_author from author
author inner join book 
on author.author_id = book.author_id
group by name_author
having count(distinct(genre_id)) = 1 

Вложенные запросы в операторах соединения
Вложенные запросы могут использоваться в операторах соединения JOIN.  При этом им необходимо присваивать имя, которое записывается сразу после закрывающей скобки вложенного запроса.

SELECT
 ...
FROM
    таблица ... JOIN  
       (
        SELECT ...
       ) имя_вложенного_запроса
    ON условие
...
Вложенный запрос может стоять как справа, так и слева от оператора JOIN. Допускается использование двух запросов в операторах соединения.

Пример

Вывести авторов, пишущих книги в самом популярном жанре. Самым популярным считать жанр, общее количество экземпляров книг которого на складе максимально. Таких жанров может быть несколько, если они имеют одинаковое максимальное значение общего количества экземпляров. Только для этого шага изменена запись в таблице book.

book_id	title	author_id	genre_id	price	amount
8	Лирика	4	2	518.9910	10
А также добавлены новые записи:

book_id	title	author_id	genre_id	price	amount
9	Герой нашего времени	5	3	570.59	2
10	Доктор Живаго	4	3	740.50	5
Рассмотрим реализацию этого запроса по шагам.

Шаг 1. Найдем общее количество книг по каждому жанру, отсортируем его по убыванию и ограничим вывод одной строкой. Рекомендуется, если запрос будет использоваться в качестве вложенного (особенно в операциях соединения), вычисляемым полям запроса давать собственное имя.

Запрос:

SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
ORDER BY sum_amount DESC
LIMIT 1
Результат:

+---------------+------------+
|  genre_id     | sum_amount |
+---------------+------------+
| 1             | 31         |
+---------------+------------+
Кажется, что, уже используя этот запрос, можно получить id самого популярного жанра. Но это не так, поскольку несколько жанров могут иметь одинаковую популярность. Поэтому нам необходим запрос, который отберет ВСЕ жанры, суммарное количество книг которых равно sum_amount.

Шаг 2. Используя запрос с предыдущего шага, найдем id самых популярных жанров.

Запрос:

SELECT query_in_1.genre_id
FROM 
    (/* выбираем код жанра и количество произведений, относящихся к нему */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id 
    )query_in_1
    INNER JOIN
    (/* выбираем запись, в которой указан код жанр с максимальным количеством книг */
      SELECT genre_id, SUM(amount) AS sum_amount
      FROM book
      GROUP BY genre_id
      ORDER BY sum_amount DESC
      LIMIT 1
     ) query_in_2
     ON query_in_1.sum_amount= query_in_2.sum_amount              
  
Результат:

+----------+
| genre_id |
+----------+
| 1        |
| 2        |
+----------+
Шаг 3. Используя запрос с шага 2, выведем фамилии авторов, которые пишут в самых популярных жанрах. В этом запросе обязательно выполнить группировку по фамилиям авторов и id жанров, так как без этого фамилии авторов будут повторяться, поскольку в таблице book есть разные книги, написанные автором в одном жанре.

Запрос:

SELECT  name_author
FROM author INNER JOIN book
     on author.author_id = book.author_id
GROUP BY name_author, genre_id
HAVING genre_id IN 
         (/* выбираем автора, если он пишет книги в самых популярных жанрах*/
          SELECT query_in_1.genre_id
          FROM 
              ( /* выбираем код жанра и количество произведений, относящихся к нему */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
               )query_in_1
          INNER JOIN 
              ( /* выбираем запись, в которой указан код жанр с максимальным количеством книг */
                SELECT genre_id, SUM(amount) AS sum_amount
                FROM book
                GROUP BY genre_id
                ORDER BY sum_amount DESC
                LIMIT 1
               ) query_in_2
          ON query_in_1.sum_amount= query_in_2.sum_amount
         );              
  
Результат:

+------------------+
| name_author      |
+------------------+
| Булгаков М.А.    |
| Достоевский Ф.М. |
| Есенин С.А.      |
| Пастернак Б.Л.   |
+------------------+
Задание
Вывести информацию о книгах, написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде.

Логическая схема базы данных:



Результат:

+-----------------------+------------------+------------+--------+--------+
| title                 | name_author      | name_genre | price  | amount |
+-----------------------+------------------+------------+--------+--------+
| Белая гвардия         | Булгаков М.А.    | Роман      | 540.50 | 5      |
| Братья Карамазовы     | Достоевский Ф.М. | Роман      | 799.01 | 3      |
| Игрок                 | Достоевский Ф.М. | Роман      | 480.50 | 10     |
| Идиот                 | Достоевский Ф.М. | Роман      | 460.00 | 10     |
| Лирика                | Пастернак Б.Л.   | Поэзия     | 518.99 | 10     |
| Мастер и Маргарита    | Булгаков М.А.    | Роман      | 670.99 | 3      |
| Стихотворения и поэмы | Есенин С.А.      | Поэзия     | 650.00 | 15     |
| Черный человек        | Есенин С.А.      | Поэзия     | 570.20 | 6      |
+-----------------------+------------------+------------+--------+--------+
Текст задания (чтобы не прокручивать страницу):

 Вывести информацию о книгах, написанных в самых популярных жанрах, в отсортированном в алфавитном порядке по названию книг виде.
 
 select title, name_author, genre_name.name_genre, price, amount
from book
inner join author on author.author_id=book.author_id
inner join (select genre.genre_id, genre.name_genre from (SELECT genre_id, SUM(amount) AS sum_amount
FROM book
GROUP BY genre_id
HAVING sum_amount >= MAX(sum_amount)) as pop_genre
join genre on genre.genre_id=pop_genre.genre_id) as genre_name
on book.genre_id=genre_name.genre_id
order by title
 
 
 Операция соединение, использование USING()
Данный шаг добавлен по предложениям пользователей (Валерий Родькин, Todor Illia  и другие).

При описании соединения таблиц с помощью JOIN в некоторых случаях вместо ON и следующего за ним условия можно использовать оператор USING().

USING позволяет указать набор столбцов, которые есть в обеих объединяемых таблицах. Если база данных хорошо спроектирована, а каждый внешний ключ имеет такое же имя, как и соответствующий первичный ключ (например, genre.genre_id = book.genre_id), тогда можно использовать предложение USING для реализации операции JOIN. 

При этом после SELECT, при использовании столбцов из USING(), необязательно указывать, из какой именно таблицы берется столбец.

Пример

Вывести название книг, фамилии и id их авторов.

Запрос:

Вариант с ON

SELECT title, name_author, author.author_id /* явно указать таблицу - обязательно */
FROM 
    author INNER JOIN book
    ON author.author_id = book.author_id;
Вариант с USING

SELECT title, name_author, author_id /* имя таблицы, из которой берется author_id, указывать не обязательно*/
FROM 
    author INNER JOIN book
    USING(author_id);
Результат (одинаковый для обоих запросов):

+-----------------------+------------------+-----------+
| title                 | name_author      | author_id |
+-----------------------+------------------+-----------+
| Мастер и Маргарита    | Булгаков М.А.    | 1         |
| Белая гвардия         | Булгаков М.А.    | 1         |
| Идиот                 | Достоевский Ф.М. | 2         |
| Братья Карамазовы     | Достоевский Ф.М. | 2         |
| Игрок                 | Достоевский Ф.М. | 2         |
| Стихотворения и поэмы | Есенин С.А.      | 3         |
| Черный человек        | Есенин С.А.      | 3         |
| Лирика                | Пастернак Б.Л.   | 4         |
+-----------------------+------------------+-----------+
Запись условия соединения с ON является более общим случаем, так как

позволяет задавать соединение не только по одноименным полям;
позволяет использовать произвольное условие на соединение таблиц, при этом в условие может включаться произвольное выражение.
Пример

В таблице supply занесена информация о книгах, поступивших на склад.

supply_id	title	author	price	amount
1	Доктор Живаго	Пастернак Б.Л.	618.99	3
2	Черный человек 	Есенин С.А.	570.20	6
3	Евгений Онегин	Пушкин А.С.	440.80	5
4	Идиот	Достоевский Ф.М.	360.80	3
Если в таблицах supply  и book есть одинаковые книги,  вывести их название и автора.

Запрос:

SELECT book.title, name_author
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author;
Результат:

+----------------+------------------+
| title          | name_author      |
+----------------+------------------+
| Идиот          | Достоевский Ф.М. |
| Черный человек | Есенин С.А.      |
+----------------+------------------+
В данном примере для соединения book и supply использовать USING нельзя, так как в таблице book фамилий авторов вообще нет (их необходимо получить из таблицы author, столбец name_author),  а в таблице supply фамилии занесены в столбец author.  

Задание
Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, а также посчитать общее количество экземпляров книг в таблицах supply и book,  столбцы назвать Название, Автор  и Количество.

Схема данных:

 



Результат:

+----------------+-------------+------------+
| Название       | Автор       | Количество |
+----------------+-------------+------------+
| Черный человек | Есенин С.А. | 12         |
+----------------+-------------+------------+
Текст задания (чтобы не прокручивать страницу):

 Если в таблицах supply  и book есть одинаковые книги, которые имеют равную цену,  вывести их название и автора, а также посчитать общее количество экземпляров книг в таблицах supply и book,  столбцы назвать Название, Автор  и Количество.

SELECT book.title Название, name_author Автор, book.amount +supply.amount as Количество
FROM 
    author 
    INNER JOIN book USING (author_id)   
    INNER JOIN supply ON book.title = supply.title 
                         and author.name_author = supply.author
                         and book.price = supply.price;
						 
						 
Задание
Придумайте один или несколько запросов для таблиц book,  author, genre и city. Проверьте, правильно ли они работают.

При желании можно формулировку запросов  разместить в комментариях. 

Размещенные задания можно использовать для закрепления материала урока.

Оценивайте понравившиеся Вам запросы.

В последнем модуле создан отдельный урок, в котором мы разместим запросы, набравшие наибольшее количество лайков. 

Логическая схема базы данных:



Структура и наполнение таблиц:

Таблица author:

author_id	name_author
1	Булгаков М.А.
2	Достоевский Ф.М.
3	Есенин С.А.
4	Пастернак Б.Л.
5	Лермонтов М.Ю.
Таблица genre:

genre_id	name_genre
1	Роман
2	Поэзия
3	Приключения
Таблица book :

book_id	title	author_id	genre_id	price	amount
1	Мастер и Маргарита	1	1	670.99	3
2	Белая гвардия	1	1	540.50	5
3	Идиот	2	1	460.00	10
4	Братья Карамазовы	2	1	799.01	3
5	Игрок	2	1	480.50	10
6	Стихотворения и поэмы	3	2	650.00	15
7	Черный человек	3	2	570.20	6
8	Лирика	4	2	518.99	2
Таблица city:

city_id	name_city
1	Москва
2	Санкт-Петербург
3	Владивосток						 

Вывести, сколько книг написано в каждом жанре и сколько экземпляров каждого жанра на складе.

SELECT name_genre, COUNT(title) AS Книги, COALESCE(SUM(amount), 0) AS Экземпляры
FROM genre LEFT JOIN book
     USING(genre_id)
GROUP BY name_genre




/* сколько процентов каждого жанра в таблице book */

select name_genre, if(sub_query_1.genre_amount is null, 0, sub_query_1.genre_amount) * 100 as percent_count
from genre
left join (
    select b.genre_id, g.name_genre, sum(b.amount) / (select sum(b.amount) as total from book as b) as genre_amount
from book as b
    left join genre as g
    using (genre_id)
group by b.genre_id) sub_query_1
using (name_genre);

/*Создаем схему*/
DROP SCHEMA IF EXISTS stepik CASCADE;
CREATE SCHEMA IF NOT EXISTS stepik;

---AUTHOR
DROP TABLE IF EXISTS stepik.author CASCADE;
CREATE TABLE IF NOT EXISTS stepik.author
(
		author_id   BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		name_author TEXT
);
INSERT INTO stepik.author(name_author)
VALUES ('Булгаков М.А.'),
       ('Достоевский Ф.М.'),
       ('Есенин С.А.'),
       ('Пастернак Б.Л.'),
       ('Лермонтов М.Ю.');


---GENRE
DROP TABLE IF EXISTS stepik.genre CASCADE;
CREATE TABLE IF NOT EXISTS stepik.genre
(
		genre_id   BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		name_genre TEXT
);
INSERT INTO stepik.genre(name_genre)
VALUES ('Роман'),
       ('Поэзия'),
       ('Приключения');


---BOOK
DROP TABLE IF EXISTS stepik.book CASCADE;
CREATE TABLE IF NOT EXISTS stepik.book
(
		book_id   BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		title     TEXT,
		author_id BIGINT NOT NULL,
		genre_id  BIGINT,
		price     DECIMAL(8, 2),
		amount    INT,
		CONSTRAINT "FK_book_author"
				FOREIGN KEY (author_id) REFERENCES stepik.author (author_id) ON DELETE CASCADE,
		CONSTRAINT "FK_book_genre"
				FOREIGN KEY (genre_id) REFERENCES stepik.genre (genre_id) ON DELETE SET NULL
);
INSERT INTO stepik.book(title, author_id, genre_id, price, amount)
VALUES ('Мастер и Маргарита', 1, 1, 670.99, 3),
       ('Белая гвардия', 1, 1, 540.50, 5),
       ('Идиот', 2, 1, 460.00, 10),
       ('Братья Карамазовы', 2, 1, 799.01, 2),
       ('Игрок', 2, 1, 480.50, 10),
       ('Стихотворения и поэмы', 3, 2, 650.00, 15),
       ('Черный человек', 3, 2, 570.20, 6),
       ('Лирика', 4, 2, 518.99, 2);


---CITY
DROP TABLE IF EXISTS stepik.city CASCADE;
CREATE TABLE IF NOT EXISTS stepik.city
(
		city_id       BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		name_city     TEXT,
		days_delivery INT
);
INSERT INTO stepik.city(name_city, days_delivery)
VALUES ('Москва', 5),
       ('Санкт-Петербург', 3),
       ('Владивосток', 12);


---CLIENT
CREATE EXTENSION IF NOT EXISTS citext;
DROP DOMAIN IF EXISTS email;
CREATE DOMAIN email AS citext
		CHECK ( value ~
		        '^[a-zA-Z0-9.!#$%&''*+/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$' );

DROP TABLE IF EXISTS stepik.client CASCADE;
CREATE TABLE IF NOT EXISTS stepik.client
(
		client_id   BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		name_client TEXT,
		city_id     BIGINT,
		email       email,
		CONSTRAINT "FK_client_city"
				FOREIGN KEY (city_id) REFERENCES stepik.city (city_id)
);
INSERT INTO stepik.client(name_client, city_id, email)
VALUES ('Баранов Павел', 3, 'baranov@test'),
       ('Абрамова Катя', 1, 'abramova@test'),
       ('Семенонов Иван', 2, 'semenov@test'),
       ('Яковлева Галина', 1, 'yakovleva@test');


---BUY
DROP TABLE IF EXISTS stepik.buy CASCADE;
CREATE TABLE IF NOT EXISTS stepik.buy
(
		buy_id          BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		buy_description TEXT,
		client_id       BIGINT DEFAULT (NULL),
		CONSTRAINT "FK_buy_client"
				FOREIGN KEY (client_id) REFERENCES stepik.client (client_id)
);
INSERT INTO stepik.buy (buy_description, client_id)
VALUES ('Доставка только вечером', 1),
       (NULL, 3),
       ('Упаковать каждую книгу по отдельности', 2),
       (NULL, 1);


---BUY_BOOK
DROP TABLE IF EXISTS stepik.buy_book CASCADE;
CREATE TABLE IF NOT EXISTS stepik.buy_book
(
		buy_book_id BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		buy_id      BIGINT,
		book_id     BIGINT,
		amount      INT,
		CONSTRAINT "FK_buy_book_buy"
				FOREIGN KEY (buy_id) REFERENCES stepik.buy (buy_id),
		CONSTRAINT "FK_buy_book_book"
				FOREIGN KEY (book_id) REFERENCES stepik.book (book_id)
);
INSERT INTO stepik.buy_book(buy_id, book_id, amount)
VALUES (1, 1, 1),
       (1, 7, 2),
       (2, 8, 2),
       (3, 3, 2),
       (3, 2, 1),
       (3, 1, 1),
       (4, 5, 1);


---STEP
DROP TABLE IF EXISTS stepik.step CASCADE;
CREATE TABLE IF NOT EXISTS stepik.step
(
		step_id   BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		name_step TEXT
);
INSERT INTO stepik.step(name_step)
VALUES ('Оплата'),
       ('Упаковка'),
       ('Транспортировка'),
       ('Доставка');


---BUY_STEP
DROP TABLE IF EXISTS stepik.buy_step CASCADE;
CREATE TABLE IF NOT EXISTS stepik.buy_step
(
		buy_step_id   BIGINT PRIMARY KEY GENERATED ALWAYS AS IDENTITY,
		buy_id        INT,
		step_id       INT,
		date_step_beg DATE,
		date_step_end DATE,
		CONSTRAINT "FK_buy_step_buy"
				FOREIGN KEY (buy_id) REFERENCES stepik.buy (buy_id),
		CONSTRAINT "FK_buy_step_step"
				FOREIGN KEY (step_id) REFERENCES stepik.step (step_id)
);
INSERT INTO stepik.buy_step(buy_id, step_id, date_step_beg, date_step_end)
VALUES (1, 1, '2020-02-20', '2020-02-20'),
       (1, 2, '2020-02-20', '2020-02-21'),
       (1, 3, '2020-02-22', '2020-03-07'),
       (1, 4, '2020-03-08', '2020-03-08'),
       (2, 1, '2020-02-28', '2020-02-28'),
       (2, 2, '2020-02-29', '2020-03-01'),
       (2, 3, '2020-03-02', NULL),
       (2, 4, NULL, NULL),
       (3, 1, '2020-03-05', '2020-03-05'),
       (3, 2, '2020-03-05', '2020-03-06'),
       (3, 3, '2020-03-06', '2020-03-10'),
       (3, 4, '2020-03-11', NULL),
       (4, 1, '2020-03-20', NULL),
       (4, 2, NULL, NULL),
       (4, 3, NULL, NULL),
       (4, 4, NULL, NULL);

Содержание урока
С помощью запросов корректировки данных решим задачу о занесении в базу книг, привезенных на склад поставщиком.

База данных о книгах  включает три таблицы genre, author и book, информация о поставке занесена в таблицу supply. С разными типами книг из поставки необходимо выполнить разные действия:

для книг, которые уже есть на складе по той же цене, что и в поставке, - увеличить их количество на значение, указанное в поставке (пример);
для книг, которые уже есть на складе, но цена книги в поставке отличается, - увеличить количество экземпляров и вычислить новую цену, при расчете учесть количество имеющихся и новых экземпляров книг (задание);
для книг, которых на складе нет, - проверить, есть ли  автор книги в базе, если нет - занести фамилию автора, а потом добавить новую запись о книге, оставив поле для описания жанра пустым;
задать жанр для новых книг.
Еще одно типовое действие на складе - удаление устаревшей информации. С помощью запросов корректировки удаление данных о жанрах, авторах и книгах выполняется в зависимости от того, какие свойства внешних ключей были указаны в таблицах при их создании:

каскадное удаление записей связанных таблиц;
удаление записей в главной таблице с сохранением записей в зависимой;
удаление записей с использованием информации из связанных таблиц.
 Структура и наполнение  таблиц
Концептуальная схема базы данных:

Логическая схема базы данных:

Таблица author(создание, заполнение):

author_id	name_author
1	Булгаков М.А.
2	Достоевский Ф.М.
3	Есенин С.А.
4	Пастернак Б.Л.
5	Лермонтов М.Ю.
Таблица genre(создание, заполнение, рассмотрено в качестве примеров):

genre_id	name_genre
1	Роман
2	Поэзия
3	Приключения
Таблица book (создание, заполнение):

book_id	title	author_id	genre_id	price	amount
1	Мастер и Маргарита	1	1	670.99	3
2	Белая гвардия	1	1	540.50	5
3	Идиот	2	1	460.00	10
4	Братья Карамазовы	2	1	799.01	3
5	Игрок	2	1	480.50	10
6	Стихотворения и поэмы	3	2	650.00	15
7	Черный человек	3	2	570.20	6
8	Лирика	4	2	518.99	2
Таблица supply(создание, заполнение):

supply_id	title	author	price	amount
1	Доктор Живаго	Пастернак Б.Л.	380.80	4
2	Черный человек 	Есенин С.А.	570.20	6
3	Белая гвардия	Булгаков М.А.	540.50	7
4	Идиот	Достоевский Ф.М.	360.80	3
5	Стихотворения и поэмы	Лермонтов М.Ю.	255.90	4
6	Остров сокровищ	Стивенсон Р.Л.	599.99	5


update book 
inner join author on book.author_id=author.author_id
inner join supply on book.title=supply.title and supply.author = author.name_author
set book.price=if(book.price <> supply.price, (book.price * book.amount + supply.price * supply.amount)/(book.amount+supply.amount), book.price),
book.amount=book.amount+supply.amount,
supply.amount=0
where book.price <> supply.price;

Запросы на добавление, связанные таблицы
Запросом на добавление можно добавить записи, отобранные с помощью запроса на выборку, который включает несколько таблиц:

INSERT INTO таблица (список_полей)
SELECT список_полей_из_других_таблиц
FROM 
    таблица_1 
    ... JOIN таблица_2 ON ...
    ...
Пример

В таблице supply  есть новые книги, которых на складе еще не было. Прежде чем добавлять их в таблицу book,  необходимо из таблицы supplyотобрать новых авторов, если таковые имеются.

Запрос:

SELECT name_author, supply.author
FROM 
    author 
    RIGHT JOIN supply ON author.name_author = supply.author;
Поскольку таблица author и поле в таблице supply называются одинаково, желательно указывать полную ссылку на поле (supply.author), чтобы запрос был более читабельным.

Результат:

+------------------+------------------+
| name_author      | author           |
+------------------+------------------+
| Булгаков М.А.    | Булгаков М.А.    |
| Достоевский Ф.М. | Достоевский Ф.М. |
| Есенин С.А.      | Есенин С.А.      |
| Пастернак Б.Л.   | Пастернак Б.Л.   |
| Лермонтов М.Ю.   | Лермонтов М.Ю.   |
| None             | Стивенсон Р.Л.   |
+------------------+------------------+
Выполнив правое внутреннее соединение таблиц, получили значение Null (None) в поле name_author в строке того автора, которого нет в таблице author, в нашем случае это Стивенсон.

Теперь достаточно в запросе задать условие отбора, и список новых авторов готов для включения в таблицу author.

Запрос:

SELECT supply.author
FROM 
    author 
    RIGHT JOIN supply on author.name_author = supply.author
WHERE name_author IS Null;
Результат:

+----------------+
| author         |
+----------------+
| Стивенсон Р.Л. |
+----------------+
Задание
Включить новых авторов в таблицу author с помощью запроса на добавление, а затем вывести все данные из таблицы author.  Новыми считаются авторы, которые есть в таблице supply, но нет в таблице author.

Результат:

Affected rows: 1

Query result:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 3         | Есенин С.А.      |
| 4         | Пастернак Б.Л.   |
| 5         | Лермонтов М.Ю.   |
| 6         | Стивенсон Р.Л.   |
+-----------+------------------+
Текст задания (чтобы не прокручивать страницу): 

Включить новых авторов в таблицу author с помощью запроса на добавление, а затем вывести все данные из таблицы author.  Новыми считаются авторы, которые есть в таблице supply, но нет в таблице author.

Структура и наполнение таблиц:
Таблица book
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
+---------+-----------------------+-----------+----------+--------+--------+
Таблица supply
+-----------+-----------------------+------------------+--------+--------+
| supply_id | title                 | author           | price  | amount |
+-----------+-----------------------+------------------+--------+--------+
| 1         | Доктор Живаго         | Пастернак Б.Л.   | 380.80 | 4      |
| 2         | Черный человек        | Есенин С.А.      | 570.20 | 12     |
| 3         | Белая гвардия         | Булгаков М.А.    | 540.50 | 7      |
| 4         | Идиот                 | Достоевский Ф.М. | 360.80 | 3      |
| 5         | Стихотворения и поэмы | Лермонтов М.Ю.   | 255.90 | 4      |
| 6         | Остров сокровищ       | Стивенсон Р.Л.   | 599.99 | 5      |
+-----------+-----------------------+------------------+--------+--------+
Таблица author                          Таблица genre
+-----------+------------------+	+----------+-------------+			
| author_id | name_author      |	| genre_id | name_genre  |			
+-----------+------------------+	+----------+-------------+			
| 1         | Булгаков М.А.    |	| 1        | Роман       |			
| 2         | Достоевский Ф.М. |	| 2        | Поэзия      |			
| 3         | Есенин С.А.      |	| 3        | Приключения |			
| 4         | Пастернак Б.Л.   |	+----------+-------------+			
| 5         | Лермонтов М.Ю.   |							
+-----------+------------------+	


INSERT INTO author (name_author)
SELECT supply.author
FROM 
    author 
    RIGHT JOIN supply on author.name_author = supply.author
WHERE name_author IS Null;

select * from author



 Занести для книги «Стихотворения и поэмы» Лермонтова жанр «Поэзия», а для книги «Остров сокровищ» Стивенсона - «Приключения». (Использовать два запроса).

Результат
Affected rows: 2

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 8       | Лирика                | 4         | 2        | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | 2        | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | 3        | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+


UPDATE book
SET genre_id = 
      (
       SELECT genre_id 
       FROM genre 
       WHERE name_genre = 'Поэзия'
      )
WHERE book_id = 10;
UPDATE book
SET genre_id = 
      (
       SELECT genre_id 
       FROM genre 
       WHERE name_genre = 'Приключения'
      )
WHERE book_id = 11;


SELECT * FROM book;


Задание
Удалить всех авторов и все их книги, общее количество книг которых меньше 20.

DELETE FROM author
WHERE author_id IN (SELECT author_id FROM book 
GROUP BY author_id
having SUM(amount)<20);


Удаление записей главной таблицы с сохранением записей в зависимой
При создании таблицы для внешних ключей с помощью ON DELETE устанавливаются опции, которые определяют действия, выполняемые при удалении связанной строки из главной таблицы.

Если задано SET NULL, то при удалении связанной строки из главной таблицы в зависимой, в столбце внешнего ключа, устанавливается значение NULL. (При этом в столбце внешнего ключа должно быть допустимо значение NULL)

В таблице book эта опция установлена на поле genre_id.

Пример

Удалим из таблицы genre все  жанры, название которых заканчиваются на «я» , а в таблице book  -  для этих жанров установим значение Null.

Запрос:

DELETE FROM genre
WHERE name_genre LIKE "%я";

SELECT * FROM genre;

SELECT * FROM book;
Результат:

Affected rows: 2

Query result:
+----------+------------+
| genre_id | name_genre |
+----------+------------+
| 1        | Роман      |
+----------+------------+
Affected rows: 1

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | None     | 650.00 | 15     |
| 7       | Черный человек        | 3         | None     | 570.20 | 12     |
| 8       | Лирика                | 4         | None     | 518.99 | 2      |
| 9       | Доктор Живаго         | 4         | 1        | 380.80 | 4      |
| 10      | Стихотворения и поэмы | 5         | None     | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | None     | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
Affected rows: 11
В нашем случае удалились жанры «Поэзия» и «Приключения».

Задание
Удалить все жанры, к которым относится меньше 4-х книг. В таблице book для этих жанров установить значение Null.


DELETE FROM genre
WHERE genre_id in (
SELECT genre_id FROM book 
GROUP BY genre_id
having SUM(genre_id)<4);

SELECT * FROM genre;
SELECT * FROM book;


Удаление записей, использование связанных таблиц
При удалении записей из таблицы можно использовать информацию из других связанных с ней таблиц. В этом случае синтаксис запроса имеет вид:

DELETE FROM таблица_1
USING 
    таблица_1 
    INNER JOIN таблица_2 ON ...
WHERE ...
Пример

Удалить всех авторов из таблицы author, у которых есть книги, количество экземпляров которых меньше 3. Из таблицы book удалить все книги этих авторов.

Запрос:

DELETE FROM author
USING 
    author 
    INNER JOIN book ON author.author_id = book.author_id
WHERE book.amount < 3;

SELECT * FROM author;

SELECT * FROM book;
Результат:

Affected rows: 1

Query result:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 3         | Есенин С.А.      |
| 5         | Лермонтов М.Ю.   |
| 6         | Стивенсон Р.Л.   |
+-----------+------------------+
Affected rows: 5

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 12     |
| 3       | Идиот                 | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 12     |
| 10      | Стихотворения и поэмы | 5         | 2        | 255.90 | 4      |
| 11      | Остров сокровищ       | 6         | 3        | 599.99 | 5      |
+---------+-----------------------+-----------+----------+--------+--------+
Книги из таблицы book будут удалены автоматически, так как для столбца author_id из таблицы book установлено каскадное удаление записей.

Задание
Удалить всех авторов, которые пишут в жанре "Поэзия". Из таблицы book удалить все книги этих авторов. В запросе для отбора авторов использовать полное название жанра, а не его id.

Результат
Affected rows: 3

Query result:
+-----------+------------------+
| author_id | name_author      |
+-----------+------------------+
| 1         | Булгаков М.А.    |
| 2         | Достоевский Ф.М. |
| 6         | Стивенсон Р.Л.   |
+-----------+------------------+
Affected rows: 3

Query result:
+---------+--------------------+-----------+----------+--------+--------+
| book_id | title              | author_id | genre_id | price  | amount |
+---------+--------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия      | 1         | 1        | 540.50 | 12     |
| 3       | Идиот              | 2         | 1        | 437.11 | 13     |
| 4       | Братья Карамазовы  | 2         | 1        | 799.01 | 3      |
| 5       | Игрок              | 2         | 1        | 480.50 | 10     |
| 11      | Остров сокровищ    | 6         | 3        | 599.99 | 5      |
+---------+--------------------+-----------+----------+--------+--------+

DELETE FROM author
USING 
    author 
    INNER JOIN book ON author.author_id = book.author_id
WHERE book.genre_id = 2;

SELECT * FROM author;

SELECT * FROM book;


DELETE FROM author
USING author 
INNER JOIN book 
USING (author_id) INNER JOIN genre USING (genre_id)
WHERE genre.name_genre LIKE 'Поэзия';

SELECT * FROM author;

SELECT * FROM book;





Запросы на основе трех и более связанных таблиц
Пример

Вывести фамилии всех клиентов, которые заказали книгу Булгакова «Мастер и Маргарита».

Запрос:

Этот запрос строится на основе нескольких таблиц, для удобства нужно определить фрагмент логической схемы базы данных, на основе которой строится запрос. В нашем случае выбираются название книги из таблицы book и фамилия клиента из таблицы client. Эти таблицы между собой непосредственно не связаны, поэтому нужно добавить «связующие» таблицы  buy и buy_book:



Для соединения этих таблиц используется INNER JOIN. Для удобства рекомендуется связи описывать последовательно: client → buy → buy_book → book.  А для соединения использовать пару первичный ключ и внешний ключ соответствующих таблиц. Например, соединение таблиц client и buy осуществляется по условию client.client_id = buy.client_id.

Чтобы не усложнять схему, будем считать, что нам известен id Булгакова (это 1)

SELECT DISTINCT name_client
FROM 
    client 
    INNER JOIN buy ON client.client_id = buy.client_id
    INNER JOIN buy_book ON buy_book.buy_id = buy.buy_id
    INNER JOIN book ON buy_book.book_id=book.book_id
WHERE title ='Мастер и Маргарита' and author_id = 1;                    
В запросе отбираются уникальные клиенты (DISTINCT) так как один и тот же клиент мог заказать одну и ту же книгу несколько раз.

Результат:

+---------------+
| name_client   |
+---------------+
| Баранов Павел |
| Абрамова Катя |
+---------------+
Задание
Вывести все заказы Баранова Павла (какие книги, по какой цене и в каком количестве он заказал) в отсортированном по номеру заказа и названиям книг виде.

Пояснение
Если в нескольких таблицах столбцы называются одинаково – необходимо явно указывать из какой таблицы берется столбец. Например, столбец amount есть и в таблице book, и в таблице buy_book. В запросе нужно указать количество заказанных книг, то есть buy_book.amount.

Результат
+--------+--------------------+--------+--------+
| buy_id | title              | price  | amount |
+--------+--------------------+--------+--------+
| 1      | Мастер и Маргарита | 670.99 | 1      |
| 1      | Черный человек     | 570.20 | 2      |
| 4      | Игрок              | 480.50 | 1      |
+--------+--------------------+--------+--------+



SELECT buy.buy_id, book.title, book.price, buy_book.amount
FROM 
    book    
    INNER JOIN buy_book ON buy_book.book_id = book.book_id
    INNER JOIN buy ON buy_book.buy_id = buy.buy_id
    INNER JOIN client ON buy.client_id=client.client_id    
    
WHERE name_client LIKE 'Баранов%'
order by buy.buy_id, book.title, book.price, buy_book.amount;


Задание
Посчитать, сколько раз была заказана каждая книга, для книги вывести ее автора (нужно посчитать, в каком количестве заказов фигурирует каждая книга).  Результат отсортировать сначала  по фамилиям авторов, а потом по названиям книг. Последний столбец назвать Количество.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу)

Посчитать, сколько раз была заказана каждая книга, для книги вывести ее автора (нужно посчитать, в каком количестве заказов фигурирует каждая книга).  Результат отсортировать сначала  по фамилиям авторов, а потом по названиям книг. Последний столбец назвать Количество.

Результат
+------------------+-----------------------+------------+
| name_author      | title                 | Количество |
+------------------+-----------------------+------------+
| Булгаков М.А.    | Белая гвардия         | 1          |
| Булгаков М.А.    | Мастер и Маргарита    | 2          |
| Достоевский Ф.М. | Братья Карамазовы     | 0          |
| Достоевский Ф.М. | Игрок                 | 1          |
| Достоевский Ф.М. | Идиот                 | 1          |
| Есенин С.А.      | Стихотворения и поэмы | 0          |
| Есенин С.А.      | Черный человек        | 1          |
| Пастернак Б.Л.   | Лирика                | 1          |
+------------------+-----------------------+------------+
Введите SQL запрос
Верно решили 4 656 учащихся
Из всех попыток 51% верных
 Правильно, молодец!
Query result:
+------------------+-----------------------+------------+
| name_author      | title                 | Количество |
+------------------+-----------------------+------------+
| Булгаков М.А.    | Белая гвардия         | 1          |
| Булгаков М.А.    | Мастер и Маргарита    | 2          |
| Достоевский Ф.М. | Братья Карамазовы     | 0          |
| Достоевский Ф.М. | Игрок                 | 1          |
| Достоевский Ф.М. | Идиот                 | 1          |
| Есенин С.А.      | Стихотворения и поэмы | 0          |
| Есенин С.А.      | Черный человек        | 1          |
| Пастернак Б.Л.   | Лирика                | 1          |
+------------------+-----------------------+------------+
Affected rows: 8
Свернуть
select author.name_author, book.title,count(buy_book.book_id) as Количество
from
author
JOIN book ON author.author_id = book.author_id
left JOIN buy_book ON book.book_id = buy_book.book_id
group by name_author, title
order by name_author, title
;
Задание 
Вывести города, в которых живут клиенты, оформлявшие заказы в интернет-магазине. Указать количество заказов в каждый город. Информацию вывести по убыванию количества заказов, а затем в алфавитном порядке по названию городов.

Фрагмент логической схемы базы данных:



Текст задания (чтобы не прокручивать страницу) :

Вывести города, в которых живут клиенты, оформлявшие заказы в интернет-магазине. Указать количество заказов в каждый город. Информацию вывести по убыванию количества заказов, а затем в алфавитном порядке по названию городов.

Результат
+-----------------+------------+
| name_city       | Количество |
+-----------------+------------+
| Владивосток     | 2          |
| Москва          | 1          |
| Санкт-Петербург | 1          |
+-----------------+------------+


select name_city, count(*) as Количество from buy
inner join client
on client.client_id=buy.client_id
inner join city
on city.city_id=client.city_id
group by name_city


Вывести номера всех оплаченных заказов и даты, когда они были оплачены.

Фрагмент логической схемы базы данных:

​​

Пояснение
Текст задания (чтобы не прокручивать страницу) :

Вывести номера всех оплаченных заказов и даты, когда они были оплачены.

Результат
+--------+---------------+
| buy_id | date_step_end |
+--------+---------------+
| 1      | 2020-02-20    |
| 2      | 2020-02-28    |
| 3      | 2020-03-05    |
+--------+---------------+


select buy_id, date_step_end from buy_step
where step_id=1 and date_step_end is not null


Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость (сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде.

Фрагмент логической схемы базы данных:

​

Текст задания (чтобы не прокручивать страницу) :

Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость (сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде.

Результат
+--------+----------------+-----------+
| buy_id | name_client    | Стоимость |
+--------+----------------+-----------+
| 1      | Баранов Павел  | 1811.39   |
| 2      | Семенонов Иван | 1037.98   |
| 3      | Абрамова Катя  | 2131.49   |
| 4      | Баранов Павел  | 480.50    |
+--------+----------------+-----------+

Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость (сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде.

Фрагмент логической схемы базы данных:

​

Текст задания (чтобы не прокручивать страницу) :

Вывести информацию о каждом заказе: его номер, кто его сформировал (фамилия пользователя) и его стоимость (сумма произведений количества заказанных книг и их цены), в отсортированном по номеру заказа виде.

Результат
+--------+----------------+-----------+
| buy_id | name_client    | Стоимость |
+--------+----------------+-----------+
| 1      | Баранов Павел  | 1811.39   |
| 2      | Семенонов Иван | 1037.98   |
| 3      | Абрамова Катя  | 2131.49   |
| 4      | Баранов Павел  | 480.50    |
+--------+----------------+-----------+


select buy.buy_id, name_client, sum(buy_book.amount*book.price) as Стоимость from buy
join client on buy.client_id=client.client_id
join buy_book on buy_book.buy_id=buy.buy_id
join book on book.book_id=buy_book.book_id
group by buy.buy_id
order by buy.buy_id


Задание
Вывести все заказы и названия этапов, на которых они в данный момент находятся. Если заказ доставлен –  информацию о нем не выводить. Информацию отсортировать по возрастанию buy_id.

Пояснение
Фрагмент логической схемы базы данных:



Текст задания (чтобы не прокручивать страницу) :

Вывести все заказы и названия этапов, на которых они в данный момент находятся. Если заказ доставлен –  информацию о нем не выводить. Информацию отсортировать по возрастанию buy_id.

Результат
+--------+-----------------+
| buy_id | name_step       |
+--------+-----------------+
| 2      | Транспортировка |
| 3      | Доставка        |
| 4      | Оплата          |

select buy.buy_id, step.name_step from buy
join buy_step on buy_step.buy_id=buy.buy_id
join step on step.step_id=buy_step.step_id
where date_step_beg is not null and date_step_end is null

Задание
В таблице city для каждого города указано количество дней, за которые заказ может быть доставлен в этот город (рассматривается только этап "Транспортировка"). Для тех заказов, которые прошли этап транспортировки, вывести количество дней за которое заказ реально доставлен в город. А также, если заказ доставлен с опозданием, указать количество дней задержки, в противном случае вывести 0. Информацию вывести в отсортированном по номеру заказа виде.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) :

В таблице city для каждого города указано количество дней, за которые заказ может быть доставлен в этот город (рассматривается только этап "Транспортировка"). Для тех заказов, которые прошли этап транспортировки, вывести количество дней за которое заказ реально доставлен в город. А также, если заказ доставлен с опозданием, указать количество дней задержки, в противном случае вывести 0. Информацию вывести в отсортированном по номеру заказа виде.

Результат
+--------+-----------------+-----------+
| buy_id | Количество_дней | Опоздание |
+--------+-----------------+-----------+
| 1      | 14              | 2         |
| 3      | 4               | 0         |
+--------+-----------------+-----------+

select buy.buy_id, 
  datediff(buy_step.date_step_end, buy_step.date_step_beg) as Количество_дней, 
  if(city.days_delivery-datediff(buy_step.date_step_end, buy_step.date_step_beg)>=0, 0, datediff(buy_step.date_step_end, buy_step.date_step_beg) - city.days_delivery) as Опоздание  
from city
join client on client.city_id=city.city_id
join buy on buy.client_id=client.client_id
join buy_step on buy_step.buy_id=buy.buy_id
where buy_step.step_id=3 and buy_step.date_step_end is not null
order by buy.buy_id

Выбрать всех клиентов, которые заказывали книги Достоевского, информацию вывести в отсортированном по алфавиту виде.

Фрагмент логической схемы:



Текст задания (чтобы не прокручивать страницу) : 

Выбрать всех клиентов, которые заказывали книги Достоевского, информацию вывести в отсортированном по алфавиту виде.

Результат
+---------------+
| name_client   |
+---------------+
| Абрамова Катя |
| Баранов Павел |

select name_client from client
join buy on buy.client_id=client.client_id
join buy_book on buy.buy_id=buy_book.buy_id
join book on book.book_id=buy_book.book_id
join author on book.author_id=author.author_id
where author.name_author like '%Достоевский%'
order by name_client

Вывести жанр (или жанры), в котором было заказано больше всего экземпляров книг, указать это количество.

Фрагмент логической схемы:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

Вывести жанр (или жанры), в котором было заказано больше всего экземпляров книг, указать это количество .

Результат
+------------+------------+
| name_genre | Количество |
+------------+------------+
| Роман      | 6          |
+------------+------------+

select name_genre, sum(buy_book.amount) as Количество from buy_book
join book on book.book_id=buy_book.book_id
join genre on genre.genre_id=book.genre_id
group by genre.genre_id, name_genre
limit 1

SELECT buy.buy_id, book.title, book.price, buy_book.amount
FROM 
    book    
    INNER JOIN buy_book ON buy_book.book_id = book.book_id
    INNER JOIN buy ON buy_book.buy_id = buy.buy_id
    INNER JOIN client ON buy.client_id=client.client_id
    
    
WHERE name_client LIKE 'Абрамова%'
order by buy.buy_id, book.title, book.price, buy_book.amount;



Задание
Этот шаг добавлен по рекомендациям пользователей: Тимур Timmmyyy, Todor Illia, Лёха Last name, Игорь Владимирович Лапшин и др.

Сравнить ежемесячную выручку от продажи книг за текущий и предыдущий годы. Для этого вывести год, месяц, сумму выручки в отсортированном сначала по возрастанию месяцев, затем по возрастанию лет виде. Название столбцов: Год, Месяц, Сумма.

Фрагмент логической схемы базы данных (в запросе НЕ ОБЯЗАТЕЛЬНО использовать все таблицы):



Информация о продажах предыдущего года хранится в архивной таблице buy_archive, которая создается в конце года на основе информации из таблиц базы данных и имеет следующую структуру:

Название столбца	Описание
buy_archive_id	ключевой столбец
buy_id	idзаказов, выбирается из таблицы buy
client_id	idклиентов, выбирается из из таблицы client
book_id	idкниги, выбирается из таблицы book
date_payment	дата оплаты заказа, выбирается из столбца date_step_end
таблицы buy_step этапа «Оплата» соответствующего заказа
price	цена книги в текущем заказе из таблицы book
(хранится, так как цена может измениться )
amount	количество купленных книг в текущем заказе, из таблицы buy_book
Оператор UNION

Оператор UNION используется для объединения двух и более SQL запросов, его синтаксис:

SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
или

SELECT столбец_1_1, столбец_1_2, ...
FROM 
  ...
UNION ALL
SELECT столбец_2_1, столбец_2_2, ...
FROM 
  ...
Важно отметить, что каждый из SELECT должен иметь в своем запросе одинаковое количество столбцов и  совместимые типы возвращаемых данных. Каждый запрос может включать разделы WHERE, GROUP BY и пр.

В результате выполнения этой конструкции будет выведена таблица, имена столбцов которой соответствуют именам столбцов в первом запросе. А в таблице результата сначала отображаются записи-результаты первого запроса, а затем второго. Если указано ключевое слово ALL, то в результат включаются все записи запросов, в противном случае - различные.

Пример

Вывести информацию об оплаченных заказах за предыдущий и текущий год, информацию отсортировать по  client_id.

Запрос:

SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"  
Результат:

+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
+--------+-----------+---------+--------------+--------+--------+
В результат включены сначала записи архивной таблицы, а затем информация об оплаченных заказах  текущего года. Для того, чтобы изменить порядок следования записей в объединенном запросе, можно использовать сортировку по всем объединенным записям. В этом случае ключевые слова ORDER BY указываются после последнего запроса: 

SELECT buy_id, client_id, book_id, date_payment, amount, price
FROM 
    buy_archive
UNION ALL
SELECT buy.buy_id, client_id, book_id, date_step_end, buy_book.amount, price
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"
ORDER BY client_id
Результат:

+--------+-----------+---------+--------------+--------+--------+
| buy_id | client_id | book_id | date_payment | amount | price  |
+--------+-----------+---------+--------------+--------+--------+
| 4      | 1         | 6       | 2019-03-12   | 1      | 650.00 |
| 2      | 1         | 1       | 2019-02-21   | 2      | 670.60 |
| 2      | 1         | 3       | 2019-02-21   | 1      | 450.90 |
| 1      | 1         | 1       | 2020-02-20   | 1      | 670.99 |
| 1      | 1         | 7       | 2020-02-20   | 2      | 570.20 |
| 3      | 2         | 3       | 2020-03-05   | 2      | 460.00 |
| 3      | 2         | 2       | 2020-03-05   | 1      | 540.50 |
| 3      | 2         | 1       | 2020-03-05   | 1      | 670.99 |
| 5      | 2         | 1       | 2019-03-18   | 2      | 670.60 |
| 5      | 2         | 4       | 2019-03-18   | 1      | 780.90 |
| 1      | 2         | 2       | 2019-02-10   | 2      | 520.30 |
| 1      | 2         | 4       | 2019-02-10   | 3      | 780.90 |
| 1      | 2         | 3       | 2019-02-10   | 1      | 450.90 |
| 2      | 3         | 8       | 2020-02-28   | 2      | 518.99 |
| 3      | 4         | 4       | 2019-03-05   | 4      | 780.90 |
| 3      | 4         | 5       | 2019-03-05   | 2      | 480.90 |
+--------+-----------+---------+--------------+--------+--------+
Текст задания (чтобы не прокручивать страницу) : 

Сравнить ежемесячную выручку от продажи книг за текущий и предыдущий годы. Для этого вывести год, месяц, сумму выручки в отсортированном сначала по возрастанию месяцев, затем по возрастанию лет виде. Название столбцов: Год, Месяц, Сумма.

Пояснение
Результат
+------+----------+---------+
| Год  | Месяц    | Сумма   |
+------+----------+---------+
| 2019 | February | 5626.30 |
| 2020 | February | 2849.37 |
| 2019 | March    | 6857.50 |
| 2020 | March    | 2131.49 |
+------+----------+---------+


SELECT YEAR(date_payment) as Год,Monthname(date_payment) as Месяц, SUM(amount * price) as Сумма
FROM 
    buy_archive
group by Monthname(date_payment), YEAR(date_payment)
UNION ALL
SELECT YEAR(date_step_end),Monthname(date_step_end), SUM(buy_book.amount * price)
FROM 
    book 
    INNER JOIN buy_book USING(book_id)
    INNER JOIN buy USING(buy_id) 
    INNER JOIN buy_step USING(buy_id)
    INNER JOIN step USING(step_id)                  
WHERE  date_step_end IS NOT Null and name_step = "Оплата"
group by Monthname(date_step_end), YEAR(date_step_end)
order by Месяц


Задание
В таблицу buy_book добавить заказ с номером 5. Этот заказ должен содержать книгу Пастернака «Лирика» в количестве двух экземпляров и книгу Булгакова «Белая гвардия» в одном экземпляре.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

В таблицу buy_book добавить заказ с номером 5. Этот заказ должен содержать книгу Пастернака «Лирика» в количестве двух экземпляров и книгу Булгакова «Белая гвардия» в одном экземпляре.

Результат
+-------------+--------+---------+--------+
| buy_book_id | buy_id | book_id | amount |
+-------------+--------+---------+--------+
| 1           | 1      | 1       | 1      |
| 2           | 1      | 7       | 2      |
| 3           | 2      | 8       | 2      |
| 4           | 3      | 3       | 2      |
| 5           | 3      | 2       | 1      |
| 6           | 3      | 1       | 1      |
| 7           | 4      | 5       | 1      |
| 8           | 5      | 8       | 2      |
| 9           | 5      | 2       | 1      |
+-------------+--------+---------+--------+

insert into buy_book(buy_id, book_id, amount)
values (5, 8, 2);
insert into buy_book(buy_id, book_id, amount)
values (5, 2, 1);



Задание
Количество тех книг на складе, которые были включены в заказ с номером 5, уменьшить на то количество, которое в заказе с номером 5  указано.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

Уменьшить количество тех книг на складе, которые были включены в заказ с номером 5.

Результат
Affected rows: 2

Query result:
+---------+-----------------------+-----------+----------+--------+--------+
| book_id | title                 | author_id | genre_id | price  | amount |
+---------+-----------------------+-----------+----------+--------+--------+
| 1       | Мастер и Маргарита    | 1         | 1        | 670.99 | 3      |
| 2       | Белая гвардия         | 1         | 1        | 540.50 | 4      |
| 3       | Идиот                 | 2         | 1        | 460.00 | 10     |
| 4       | Братья Карамазовы     | 2         | 1        | 799.01 | 3      |
| 5       | Игрок                 | 2         | 1        | 480.50 | 10     |
| 6       | Стихотворения и поэмы | 3         | 2        | 650.00 | 15     |
| 7       | Черный человек        | 3         | 2        | 570.20 | 6      |
| 8       | Лирика                | 4         | 2        | 518.99 | 0      |
+---------+-----------------------+-----------+----------+--------+--------+

UPDATE book 
     INNER JOIN buy_book
     on book.book_id = buy_book.book_id
           SET book.amount = book.amount-buy_book.amount   
WHERE buy_book.buy_id = 5 ;


Создать счет (таблицу buy_pay) на оплату заказа с номером 5, в который включить название книг, их автора, цену, количество заказанных книг и  стоимость. Информацию в таблицу занести в отсортированном по названиям книг виде.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

Создать счет (таблицу buy_pay) на оплату заказа с номером 5, в который включить название книг, их автора, цену, количество заказанных книг и  стоимость. Информацию в таблицу занести в отсортированном по названиям книг виде.

Результат
Affected rows: 2

Query result:
+---------------+----------------+--------+--------+-----------+
| title         | name_author    | price  | amount | Стоимость |
+---------------+----------------+--------+--------+-----------+
| Белая гвардия | Булгаков М.А.  | 540.50 | 1      | 540.50    |
| Лирика        | Пастернак Б.Л. | 518.99 | 2      | 1037.98   |
+---------------+----------------+--------+--------+-----------+

UPDATE book 
     INNER JOIN buy_book
     on book.book_id = buy_book.book_id
           SET book.amount = book.amount-buy_book.amount   
WHERE buy_book.buy_id = 5 ;

Задание
Создать счет (таблицу buy_pay) на оплату заказа с номером 5, в который включить название книг, их автора, цену, количество заказанных книг и  стоимость. Информацию в таблицу занести в отсортированном по названиям книг виде.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

Создать счет (таблицу buy_pay) на оплату заказа с номером 5, в который включить название книг, их автора, цену, количество заказанных книг и  стоимость. Информацию в таблицу занести в отсортированном по названиям книг виде.

Результат
Affected rows: 2

Query result:
+---------------+----------------+--------+--------+-----------+
| title         | name_author    | price  | amount | Стоимость |
+---------------+----------------+--------+--------+-----------+
| Белая гвардия | Булгаков М.А.  | 540.50 | 1      | 540.50    |
| Лирика        | Пастернак Б.Л. | 518.99 | 2      | 1037.98   |
+---------------+----------------+--------+--------+-----------+


create table buy_pay(title varchar(50), name_author varchar(30), price decimal(8,2), amount int, Стоимость decimal(8,2)); 

insert into buy_pay (title, name_author, price, amount, Стоимость) 
select book.title, author.name_author, book.price, buy_book.amount, book.price*buy_book.amount from author 
inner join book on author.author_id = book.author_id 
inner join buy_book on book.book_id = buy_book.book_id 
where buy_book.buy_id = 5 
order by title; 

select title, name_author, price, amount, Стоимость from buy_pay;


Задание
Создать общий счет (таблицу buy_pay) на оплату заказа с номером 5. Куда включить номер заказа, количество книг в заказе и его общую стоимость. Для решения используйте ОДИН запрос.

Фрагмент логической схемы базы данных:



Текст задания (чтобы не прокручивать страницу) : 

Создать общий счет (таблицу buy_pay) на оплату заказа с номером 5. Куда включить номер заказа, количество книг в заказе и его общую стоимость. Для решения используйте ОДИН запрос.

Результат
Affected rows: 1

Query result:
+--------+------------+---------+
| buy_id | Количество | Итого   |
+--------+------------+---------+
| 5      | 3          | 1578.48 |
+--------+------------+---------+

create table buy_pay
select buy_id, sum(buy_book.amount) as Количество, sum(price*buy_book.amount) as Итого from buy_book
inner join book on book.book_id=buy_book.book_id
where buy_id=5
group by buy_id



Задание
В таблицу buy_step для заказа с номером 5 включить все этапы из таблицы step, которые должен пройти этот заказ. В столбцы date_step_beg и date_step_end всех записей занести Null.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

В таблицу buy_step для заказа с номером 5 включить все этапы из таблицы step, которые должен пройти этот заказ. В столбцы date_step_beg и date_step_end всех записей занести Null.

Результат
Affected rows: 4

Query result:
+-------------+--------+---------+---------------+---------------+
| buy_step_id | buy_id | step_id | date_step_beg | date_step_end |
+-------------+--------+---------+---------------+---------------+
| 1           | 1      | 1       | 2020-02-20    | 2020-02-20    |
| 2           | 1      | 2       | 2020-02-20    | 2020-02-21    |
| 3           | 1      | 3       | 2020-02-22    | 2020-03-07    |
| 4           | 1      | 4       | 2020-03-06    | 2020-03-06    |
| 5           | 2      | 1       | 2020-02-28    | 2020-02-28    |
| 6           | 2      | 2       | 2020-02-29    | 2020-03-01    |
| 7           | 2      | 3       | 2020-03-02    | None          |
| 8           | 2      | 4       | None          | None          |
| 9           | 3      | 1       | 2020-03-05    | 2020-03-05    |
| 10          | 3      | 2       | 2020-03-05    | 2020-03-06    |
| 11          | 3      | 3       | 2020-03-06    | 2020-03-10    |
| 12          | 3      | 4       | 2020-03-11    | None          |
| 13          | 4      | 1       | 2020-03-20    | None          |
| 14          | 4      | 2       | None          | None          |
| 15          | 4      | 3       | None          | None          |
| 16          | 4      | 4       | None          | None          |
| 17          | 5      | 1       | None          | None          |
| 18          | 5      | 2       | None          | None          |
| 19          | 5      | 3       | None          | None          |
| 20          | 5      | 4       | None          | None          |
+-------------+--------+---------+---------------+---------------+

insert into buy_step(buy_id, step_id)
select buy_id, step_id from buy
cross join step
where buy_id=5


Задание
В таблицу buy_step занести дату 12.04.2020 выставления счета на оплату заказа с номером 5.

Правильнее было бы занести не конкретную, а текущую дату. Это можно сделать с помощью функции Now(). Но при этом в разные дни будут вставляться разная дата, и задание нельзя будет проверить, поэтому  вставим дату 12.04.2020.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

В таблицу buy_step занести дату 12.04.2020 выставления счета на оплату заказа с номером 5.

Правильнее было бы занести не конкретную, а текущую дату. Это можно сделать с помощью функции Now(). Но при этом в разные дни будут вставляться разная дата, и задание нельзя будет проверить, поэтому  вставим дату 12.04.2020.

Результат
Affected rows: 1

Query result:
+-------------+--------+---------+---------------+---------------+
| buy_step_id | buy_id | step_id | date_step_beg | date_step_end |
+-------------+--------+---------+---------------+---------------+
| 17          | 5      | 1       | 2020-04-12    | None          |
| 18          | 5      | 2       | None          | None          |
| 19          | 5      | 3       | None          | None          |
| 20          | 5      | 4       | None          | None          |
+-------------+--------+---------+---------------+---------------+


update buy_step
set date_step_beg='2020-04-12'
where buy_id=5 and step_id=1


Задание
Завершить этап «Оплата» для заказа с номером 5, вставив в столбец date_step_end дату 13.04.2020, и начать следующий этап («Упаковка»), задав в столбце date_step_beg для этого этапа ту же дату.

Реализовать два запроса для завершения этапа и начала следующего. Они должны быть записаны в общем виде, чтобы его можно было применять для любых этапов, изменив только текущий этап. Для примера пусть это будет этап «Оплата».

Фрагмент предметной области:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

Завершить этап «Оплата» для заказа с номером 5, вставив в столбец date_step_end дату 13.04.2020, и начать следующий этап («Упаковка»), задав в столбце date_step_beg для этого этапа ту же дату.

Реализовать два запроса для завершения этапа и начале следующего. Они должны быть записаны в общем виде, чтобы его можно было применять для любых этапов, изменив только текущий этап. Для примера пусть это будет этап «Оплата».

Результат
Affected rows: 1

Affected rows: 1

Query result:
+-------------+--------+---------+---------------+---------------+
| buy_step_id | buy_id | step_id | date_step_beg | date_step_end |
+-------------+--------+---------+---------------+---------------+
| 17          | 5      | 1       | 2020-04-12    | 2020-04-13    |
| 18          | 5      | 2       | 2020-04-13    | None          |
| 19          | 5      | 3       | None          | None          |
| 20          | 5      | 4       | None          | None          |
+-------------+--------+---------+---------------+---------------+


update buy_step
set date_step_end='2020-04-13'
where buy_id=5 and step_id=1;


Задание
Завершить этап «Оплата» для заказа с номером 5, вставив в столбец date_step_end дату 13.04.2020, и начать следующий этап («Упаковка»), задав в столбце date_step_beg для этого этапа ту же дату.

Реализовать два запроса для завершения этапа и начала следующего. Они должны быть записаны в общем виде, чтобы его можно было применять для любых этапов, изменив только текущий этап. Для примера пусть это будет этап «Оплата».

Фрагмент предметной области:



Пояснение
Текст задания (чтобы не прокручивать страницу) : 

Завершить этап «Оплата» для заказа с номером 5, вставив в столбец date_step_end дату 13.04.2020, и начать следующий этап («Упаковка»), задав в столбце date_step_beg для этого этапа ту же дату.

Реализовать два запроса для завершения этапа и начале следующего. Они должны быть записаны в общем виде, чтобы его можно было применять для любых этапов, изменив только текущий этап. Для примера пусть это будет этап «Оплата».

Результат
Affected rows: 1

Affected rows: 1

Query result:
+-------------+--------+---------+---------------+---------------+
| buy_step_id | buy_id | step_id | date_step_beg | date_step_end |
+-------------+--------+---------+---------------+---------------+
| 17          | 5      | 1       | 2020-04-12    | 2020-04-13    |
| 18          | 5      | 2       | 2020-04-13    | None          |
| 19          | 5      | 3       | None          | None          |
| 20          | 5      | 4       | None          | None          |
+-------------+--------+---------+---------------+---------------+


update buy_step
set date_step_end='2020-04-13'
where buy_id=5 and step_id=1;
update buy_step
set date_step_beg='2020-04-13'
where buy_id=5 and step_id=2;



Задание
Создать новый заказ для Попова Ильи. Его комментарий для заказа: «Связаться со мной по вопросу доставки».

Фрагмент логической схемы базы данных:



Текст задания (чтобы не прокручивать страницу) : 

 Создать новый заказ для Попова Ильи. Его комментарий для заказа: «Связаться со мной по вопросу доставки».

Важно!. В решении нельзя использоваться VALUES и делать отбор по client_id.

Affected rows: 1

Query result:
+--------+---------------------------------------+-----------+
| buy_id | buy_description                       | client_id |
+--------+---------------------------------------+-----------+
| 1      | Доставка только вечером               | 1         |
| 2      | None                                  | 3         |
| 3      | Упаковать каждую книгу по отдельности | 2         |
| 4      | None                                  | 1         |
| 5      | Связаться со мной по вопросу доставки | 5         |
+--------+---------------------------------------+-----------+

INSERT INTO buy (buy_description , client_id)
SELECT 'Связаться со мной по вопросу доставки', client_id 
FROM client
where name_client like "Попов%" ;
select * from buy




Код базы для SQLite

CREATE TABLE `student` (
`student_id` INTEGER PRIMARY KEY AUTOINCREMENT,
`name_student` varchar(50) DEFAULT NULL
);
CREATE TABLE `subject` (
`subject_id` INTEGER PRIMARY KEY AUTOINCREMENT,
`name_subject` varchar(30) DEFAULT NULL
);
CREATE TABLE `attempt` (
`attempt_id` INTEGER PRIMARY KEY AUTOINCREMENT,
student_id int DEFAULT NULL,
`subject_id` int DEFAULT NULL,
`date_attempt` date DEFAULT NULL,
`result` int DEFAULT NULL,
CONSTRAINT `attempt_ibfk_1` FOREIGN KEY (`student_id`) REFERENCES `student` (`student_id`) ON DELETE CASCADE,
CONSTRAINT `attempt_ibfk_2` FOREIGN KEY (`subject_id`) REFERENCES `subject` (`subject_id`) ON DELETE CASCADE
);
CREATE TABLE `testing` (
`testing_id` INTEGER PRIMARY KEY AUTOINCREMENT,
`attempt_id` int DEFAULT NULL,
`question_id` int DEFAULT NULL,
`answer_id` int DEFAULT NULL,
CONSTRAINT `testing_ibfk_1` FOREIGN KEY (`attempt_id`) REFERENCES `attempt` (`attempt_id`) ON DELETE CASCADE
);
CREATE TABLE `question` (
`question_id` INTEGER PRIMARY KEY AUTOINCREMENT,
`name_question` varchar(100) DEFAULT NULL, 
`subject_id` int DEFAULT NULL,
CONSTRAINT `question_ibfk_1` FOREIGN KEY (`subject_id`) REFERENCES `subject` (`subject_id`) ON DELETE CASCADE
);
CREATE TABLE `answer` (
`answer_id` INTEGER PRIMARY KEY AUTOINCREMENT,
`name_answer` varchar(100) DEFAULT NULL,
`question_id` int DEFAULT NULL,
`is_correct` tinyint(1) DEFAULT NULL,
CONSTRAINT `answer_ibfk_1` FOREIGN KEY (`question_id`) REFERENCES `question` (`question_id`) ON DELETE CASCADE
);

INSERT INTO subject (subject_id,name_subject) VALUES 
(1,'Основы SQL'),
(2,'Основы баз данных'),
(3,'Физика');

INSERT INTO student (student_id,name_student) VALUES
(1,'Баранов Павел'),
(2,'Абрамова Катя'),
(3,'Семенов Иван'),
(4,'Яковлева Галина');

INSERT INTO attempt (attempt_id,student_id,subject_id,date_attempt,result) VALUES
(1,1,2,'2020-03-23',67),
(2,3,1,'2020-03-23',100),
(3,4,2,'2020-03-26',0),
(4,1,1,'2020-04-15',33),
(5,3,1,'2020-04-15',67),
(6,4,2,'2020-04-21',100),
(7,3,1,'2020-05-17',33);

INSERT INTO question (question_id,name_question,subject_id) VALUES
(1,'Запрос на выборку начинается с ключевого слова:',1),
(2,'Условие, по которому отбираются записи, задается после ключевого слова:',1),
(3,'Для сортировки используется:',1),
(4,'Какой запрос выбирает все записи из таблицы student:',1),
(5,'Для внутреннего соединения таблиц используется оператор:',1),
(6,'База данных - это:',2),
(7,'Отношение - это:',2),
(8,'Концептуальная модель используется для',2),
(9,'Какой тип данных не допустим в реляционной таблице?',2);

INSERT INTO answer (answer_id,name_answer,question_id,is_correct) VALUES
(1,'UPDATE',1,0),
(2,'SELECT',1,1),
(3,'INSERT',1,0),
(4,'GROUP BY',2,0),
(5,'FROM',2,0),
(6,'WHERE',2,1),
(7,'SELECT',2,0),
(8,'SORT',3,0),
(9,'ORDER BY',3,1),
(10,'RANG BY',3,0),
(11,'SELECT * FROM student',4,1),
(12,'SELECT student',4,0),
(13,'INNER JOIN',5,1),
(14,'LEFT JOIN',5,0),
(15,'RIGHT JOIN',5,0),
(16,'CROSS JOIN',5,0),
(17,'совокупность данных, организованных по определенным правилам',6,1),
(18,'совокупность программ для хранения и обработки больших массивов информации',6,0),
(19,'строка',7,0),
(20,'столбец',7,0),
(21,'таблица',7,1),
(22,'обобщенное представление пользователей о данных',8,1),
(23,'описание представления данных в памяти компьютера',8,0),
(24,'база данных',8,0),
(25,'file',9,1),
(26,'INT',9,0),
(27,'VARCHAR',9,0),
(28,'DATE',9,0);

INSERT INTO testing (testing_id,attempt_id,question_id,answer_id) VALUES
(1,1,9,25),
(2,1,7,19),
(3,1,6,17),
(4,2,3,9),
(5,2,1,2),
(6,2,4,11),
(7,3,6,18),
(8,3,8,24),
(9,3,9,28),
(10,4,1,2),
(11,4,5,16),
(12,4,3,10),
(13,5,2,6),
(14,5,1,2),
(15,5,4,12),
(16,6,6,17),
(17,6,8,22),
(18,6,7,21),
(19,7,1,3),
(20,7,4,11),
(21,7,5,16);


Задание
Вывести студентов, которые сдавали дисциплину «Основы баз данных», указать дату попытки и результат. Информацию вывести по убыванию результатов тестирования.

Фрагмент логической схемы базы данных



Текст задания (чтобы не прокручивать страницу)

 Вывести студентов, которые сдавали дисциплину «Основы баз данных», указать дату попытки и результат. Информацию вывести по убыванию результатов тестирования.

Результат
+-----------------+--------------+--------+
| name_student    | date_attempt | result |
+-----------------+--------------+--------+
| Яковлева Галина | 2020-04-21   | 100    |
| Баранов Павел   | 2020-03-23   | 67     |
| Яковлева Галина | 2020-03-26   | 0      |
+-----------------+--------------+--------+
Структура и наполнение таблиц
Таблица attempt
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
+------------+------------+------------+--------------+--------+
Таблица student                   Таблица subject
+------------+-----------------+  +------------+-------------------+
| student_id | name_student    |  | subject_id | name_subject      |
+------------+-----------------+  +------------+-------------------+
| 1          | Баранов Павел   |  | 1          | Основы SQL        |
| 2          | Абрамова Катя   |  | 2          | Основы баз данных |
| 3          | Семенов Иван    |  | 3          | Физика            |
| 4          | Яковлева Галина |  +------------+-------------------+
+------------+-----------------+

select student.name_student, attempt.date_attempt, attempt.result
from student
INNER JOIN attempt USING(student_id)
INNER JOIN subject USING(subject_id)
where name_subject LIKE "Основы баз данных"
order by result DESC;

Задание
Вывести, сколько попыток сделали студенты по каждой дисциплине, а также средний результат попыток, который округлить до 2 знаков после запятой. Под результатом попытки понимается процент правильных ответов на вопросы теста, который занесен в столбец result.  Информацию вывести по убыванию средних результатов.

Фрагмент логической схемы базы данных



Пояснение
Текст задания (чтобы не прокручивать страницу)

Вывести, сколько попыток сделали студенты по каждой дисциплине, а также средний результат попыток, который округлить до 2 знаков после запятой. Под результатом попытки понимается процент правильных ответов на вопросы теста, который занесен в столбец result.  Информацию вывести по убыванию средних результатов.

Результат
+-------------------+------------+---------+
| name_subject      | Количество | Среднее |
+-------------------+------------+---------+
| Основы SQL        | 4          | 58.25   |
| Основы баз данных | 3          | 55.67   |
| Физика            | 0          | None    |
+-------------------+------------+---------+
Структура и наполнение таблиц attempt и subject

+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
+------------+------------+------------+--------------+--------+
+------------+-------------------+
| subject_id | name_subject      |
+------------+-------------------+
| 1          | Основы SQL        |
| 2          | Основы баз данных |
| 3          | Физика            |
+------------+-------------------+

select name_subject, count(result) as Количество, round(avg(result),2) as Среднее
from subject
left JOIN attempt USING(subject_id)
group by name_subject

Задание
Вывести студента (различных студентов), имеющих максимальные результаты попыток. Информацию отсортировать в алфавитном порядке по фамилии студента.

Максимальный результат не обязательно будет 100%, поэтому явно это значение в запросе не задавать.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу)

Вывести студента (различных студентов), имеющих максимальные результаты попыток . Информацию отсортировать в алфавитном порядке по фамилии студента.

Результат
+-----------------+--------+
| name_student    | result |
+-----------------+--------+
| Семенов Иван    | 100    |
| Яковлева Галина | 100    |
+-----------------+--------+

select name_student, result from attempt
join student on student.student_id=attempt.student_id
where result=(select max(result) from attempt)
order by name_student;

Задание
Если студент совершал несколько попыток по одной и той же дисциплине, то вывести разницу в днях между первой и последней попыткой. Информацию вывести по возрастанию разницы. Студентов, сделавших одну попытку по дисциплине, не учитывать.

Фрагмент логической схемы базы данных



Пояснение
Текст задания (чтобы не прокручивать страницу)

Если студент совершал несколько попыток по одной и той же дисциплине, то вывести разницу в днях между первой и последней попыткой. Информацию вывести по возрастанию разницы. Студентов, сделавших одну попытку по дисциплине, не учитывать.

Результат
+-----------------+-------------------+----------+
| name_student    | name_subject      | Интервал |
+-----------------+-------------------+----------+
| Яковлева Галина | Основы баз данных | 26       |
| Семенов Иван    | Основы SQL        | 55       |
+-----------------+-------------------+----------+


select name_student, name_subject, datediff(max(date_attempt), min(date_attempt)) as Интервал from attempt
join student on student.student_id=attempt.student_id
join subject on subject.subject_id=attempt.subject_id
group by name_student, name_subject
having count(*)>1
order by Интервал


Задание
Студенты могут тестироваться по одной или нескольким дисциплинам (не обязательно по всем). Вывести дисциплину и количество уникальных студентов, которые по ней проходили тестирование . Информацию отсортировать сначала по убыванию количества, а потом по названию дисциплины. В результат включить и дисциплины, тестирование по которым студенты еще не проходили, в этом случае указать количество студентов 0.

Пояснение
Фрагмент логической схемы базы данных



Пояснение
Текст задания (чтобы не прокручивать страницу)

Студенты могут тестироваться по одной или нескольким дисциплинам (не обязательно по всем). Вывести дисциплину и количество уникальных студентов, которые по ней проходили тестирование . Информацию отсортировать сначала по убыванию количества, а потом по названию дисциплины. В результат включить и дисциплины, тестирование по которым студенты не проходили, в этом случае указать количество студентов 0.

Результат
+-------------------+------------+
| name_subject      | Количество |
+-------------------+------------+
| Основы SQL        | 2          |
| Основы баз данных | 2          |
| Физика            | 0          |
+-------------------+------------+

select name_subject, count(distinct attempt.student_id) as Количество from subject
left join attempt on attempt.subject_id=subject.subject_id
group by subject.subject_id
order by name_subject, Количество desc


Задание
Случайным образом отберите 3 вопроса по дисциплине «Основы баз данных».

Фрагмент логической схемы базы данных



Пояснение
Текст задания (чтобы не прокручивать страницу)

Случайным образом отберите 3 вопроса по дисциплине «Основы баз данных».

Результат
Примечание: вопросы выбираются случайным образом, поэтому результат выполнения запроса может не совпадать с образцом

+-------------+----------------------------------------+
| question_id | name_question                          |
+-------------+----------------------------------------+
| 8           | Концептуальная модель используется для |
| 7           | Отношение - это:                       |
| 6           | База данных - это:                     |
+-------------+----------------------------------------+

select question_id, name_question from question
join subject on subject.subject_id=question.subject_id
where subject.name_subject='Основы баз данных'
order by rand()
limit 3

Задание
Вывести вопросы, которые были включены в тест для Семенова Ивана по дисциплине «Основы SQL» 2020-05-17  (значение attempt_id для этой попытки равно 7). Указать, какой ответ дал студент и правильный он или нет.

Фрагмент логической схемы базы данных



Пояснение
Текст задания (чтобы не прокручивать страницу)

Вывести вопросы, которые были включены в тест для Семенова Ивана по дисциплине «Основы SQL» 2020-05-17  (значение attempt_id для этой попытки равно 7). Указать, какой ответ дал студент и правильный он или нет.

Результат
+----------------------------------------------------------+-----------------------+-----------+
| name_question                                            | name_answer           | Результат |
+----------------------------------------------------------+-----------------------+-----------+
| Запрос на выборку начинается с ключевого слова:          | INSERT                | Неверно   |
| Какой запрос выбирает все записи из таблицы student:     | SELECT * FROM student | Верно     |
| Для внутреннего соединения таблиц используется оператор: | CROSS JOIN            | Неверно   |
+----------------------------------------------------------+-----------------------+-----------+
3.1.8
select name_question, name_answer, if(is_correct, 'Верно', 'Неверно') as Результат from question
join testing on question.question_id=testing.question_id
join answer on answer.answer_id=testing.answer_id
where testing.attempt_id=7


Посчитать результаты тестирования. Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до двух знаков после запятой. Вывести фамилию студента, название предмета, дату и результат. Информацию отсортировать сначала по фамилии студента, потом по убыванию даты попытки.

Пояснение
Логическая схема базы данных (чтобы потренироваться выбирать нужные таблицы):



Текст задания (чтобы не прокручивать страницу)

Посчитать результаты тестирования. Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до двух знаков после запятой. Вывести фамилию студента, название предмета, дату и результат. Информацию отсортировать сначала по фамилии студента, потом по убыванию даты попытки.

Результат
+-----------------+-------------------+--------------+-----------+
| name_student    | name_subject      | date_attempt | Результат |
+-----------------+-------------------+--------------+-----------+
| Баранов Павел   | Основы SQL        | 2020-04-15   | 33.33     |
| Баранов Павел   | Основы баз данных | 2020-03-23   | 66.67     |
| Семенов Иван    | Основы SQL        | 2020-05-17   | 33.33     |
| Семенов Иван    | Основы SQL        | 2020-04-15   | 66.67     |
| Семенов Иван    | Основы SQL        | 2020-03-23   | 100.00    |
| Яковлева Галина | Основы баз данных | 2020-04-21   | 100.00    |
| Яковлева Галина | Основы баз данных | 2020-03-26   | 0.00      |
+-----------------+-------------------+--------------+-----------+

3.1.9
select name_student, name_subject, date_attempt, round(sum(is_correct)/3*100, 2) as Результат from answer
join testing on testing.answer_id=answer.answer_id
join attempt on attempt.attempt_id=testing.attempt_id
join subject on subject.subject_id=attempt.subject_id
join student on student.student_id=attempt.student_id
group by name_student, name_subject, date_attempt
order by name_student, date_attempt desc


Задание
Для каждого вопроса вывести процент успешных решений, то есть отношение количества верных ответов к общему количеству ответов, значение округлить до 2-х знаков после запятой. Также вывести название предмета, к которому относится вопрос, и общее количество ответов на этот вопрос. Информацию отсортировать сначала по названию дисциплины, потом по убыванию успешности, а потом по тексту вопроса в алфавитном порядке.

Поскольку тексты вопросов могут быть длинными, обрезать их 30 символов и добавить многоточие "...".

Логическая схема базы данных (чтобы потренироваться выбирать таблицы):



Пояснение
Текст задания (чтобы не прокручивать страницу)

Для каждого вопроса вывести процент успешных решений, то есть отношение количества верных ответов к общему количеству ответов, значение округлить до 2-х знаков после запятой. Также вывести название предмета, к которому относится вопрос, и общее количество ответов на этот вопрос. Информацию отсортировать сначала по названию дисциплины, потом по убыванию успешности, а потом по тексту вопроса в алфавитном порядке.

Поскольку тексты вопросов могут быть длинными, обрезать их 30 символов и добавить многоточие "...".

Результат
+-------------------+-----------------------------------+---------------+------------+
| name_subject      | Вопрос                            | Всего_ответов | Успешность |
+-------------------+-----------------------------------+---------------+------------+
| Основы SQL        | Условие, по которому отбираютс... | 1             | 100.00     |
| Основы SQL        | Запрос на выборку начинается с... | 4             | 75.00      |
| Основы SQL        | Какой запрос выбирает все запи... | 3             | 66.67      |
| Основы SQL        | Для сортировки используется:...   | 2             | 50.00      |
| Основы SQL        | Для внутреннего соединения таб... | 2             | 0.00       |
| Основы баз данных | База данных - это:...             | 3             | 66.67      |
| Основы баз данных | Какой тип данных не допустим в... | 2             | 50.00      |
| Основы баз данных | Концептуальная модель использу... | 2             | 50.00      |
| Основы баз данных | Отношение - это:...               | 2             | 50.00      |
+-------------------+-----------------------------------+---------------+------------+

3.1.10
select name_subject,concat(left(name_question, 30), '...') as Вопрос, count(*) as Всего_ответов,
round(sum(is_correct)/count(*)*100, 2) as Успешность
from subject
join question using(subject_id)
join testing using(question_id)
join answer using(answer_id)
group by question.question_id
order by name_subject, Успешность desc, Вопрос


select
name_subject,
concat(left(name_question, 30), '...') as Вопросы,
count(*) as Всего_ответов,
round(sum(is_correct)/count(*)*100, 2) as Успеваемость
from subject
join question on question.subject_id=subject.subject_id
join testing on question.question_id=testing.question_id
join answer on answer.answer_id=testing.answer_id
group by question.question_id
order by Успеваемость desc


Задание
В таблицу attempt включить новую попытку для студента Баранова Павла по дисциплине «Основы баз данных». Установить текущую дату в качестве даты выполнения попытки.

Фрагмент логической схемы базы данных



Пояснение
Текст задания (чтобы не прокручивать страницу) :

В таблицу attempt включить новую попытку для студента Баранова Павла по дисциплине «Основы баз данных». Установить текущую дату в качестве даты выполнения попытки.

Результат
Примечание: дата попытки при запуске запроса будет отличаться от образца.

Affected rows: 1

Query result:
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2020-06-12   | None   |
+------------+------------+------------+--------------+--------+


3.2.2
insert into attempt(student_id, subject_id, date_attempt, result)
values (1, 2, now(), null);

select * from attempt


Задание
Случайным образом выбрать три вопроса (запрос) по дисциплине, тестирование по которой собирается проходить студент, занесенный в таблицу attempt последним, и добавить их в таблицу testing. id последней попытки получить как максимальное значение id из таблицы attempt.

Фрагмент логической схемы базы данных



Пояснение
Корректируемая таблица:



Текст задания (чтобы не прокручивать страницу) :

 Случайным образом выбрать три вопроса (запрос) по дисциплине, тестирование по которой собирается проходить студент, занесенный в таблицу attempt последним, и добавить их в таблицу testing.id последней попытки получить как максимальное значение id из таблицы attempt.

Результат
Примечание: при выполнении запроса номера вставленных вопросов будут отличаться от образца, поскольку выбираются случайным образом.

Affected rows: 3

Query result:
+------------+------------+-------------+-----------+
| testing_id | attempt_id | question_id | answer_id |
+------------+------------+-------------+-----------+
| 1          | 1          | 9           | 25        |
| 2          | 1          | 7           | 19        |
| 3          | 1          | 6           | 17        |
| 4          | 2          | 3           | 9         |
| 5          | 2          | 1           | 2         |
| 6          | 2          | 4           | 11        |
| 7          | 3          | 6           | 18        |
| 8          | 3          | 8           | 24        |
| 9          | 3          | 9           | 28        |
| 10         | 4          | 1           | 2         |
| 11         | 4          | 5           | 16        |
| 12         | 4          | 3           | 10        |
| 13         | 5          | 2           | 6         |
| 14         | 5          | 1           | 2         |
| 15         | 5          | 4           | 12        |
| 16         | 6          | 6           | 17        |
| 17         | 6          | 8           | 22        |
| 18         | 6          | 7           | 21        |
| 19         | 7          | 1           | 3         |
| 20         | 7          | 4           | 11        |
| 21         | 7          | 5           | 16        |
| 22         | 8          | 6           | None      |
| 23         | 8          | 8           | None      |
| 24         | 8          | 7           | None      |
+------------+------------+-------------+-----------+


3.2.3

insert into testing(attempt_id, question_id)
select attempt_id, question.question_id from question
join subject on subject.subject_id=question.subject_id
join attempt on attempt.subject_id=question.subject_id
where subject.subject_id=2 and attempt_id=(select max(attempt_id) from attempt)
order by rand()
limit 3
;
select * from testing



Задание
Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.

 Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 8. В таблицу testing занесены следующие ответы пользователя:

+------------+------------+-------------+-----------+
| testing_id | attempt_id | question_id | answer_id |
+------------+------------+-------------+-----------+
| 22         | 8          | 7           | 19        |
| 23         | 8          | 6           | 17        |
| 24         | 8          | 8           | 22        |
+------------+------------+-------------+-----------+
Фрагмент логической схемы базы данных:



Корректируемая таблица:



Пояснение
Текст задания (чтобы не прокручивать страницу) :

Студент прошел тестирование (то есть все его ответы занесены в таблицу testing), далее необходимо вычислить результат(запрос) и занести его в таблицу attempt для соответствующей попытки.  Результат попытки вычислить как количество правильных ответов, деленное на 3 (количество вопросов в каждой попытке) и умноженное на 100. Результат округлить до целого.

 Будем считать, что мы знаем id попытки,  для которой вычисляется результат, в нашем случае это 8.

Результат
Affected rows: 1

Query result:
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 1          | 1          | 2          | 2020-03-23   | 67     |
| 2          | 3          | 1          | 2020-03-23   | 100    |
| 3          | 4          | 2          | 2020-03-26   | 0      |
| 4          | 1          | 1          | 2020-04-15   | 33     |
| 5          | 3          | 1          | 2020-04-15   | 67     |
| 6          | 4          | 2          | 2020-04-21   | 100    |
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2020-06-12   | 67     |
+------------+------------+------------+--------------+--------+



3.2.4
update attempt,
(
    select student.student_id, subject.subject_id, date_attempt, round(sum(is_correct)/3*100) as result from answer
    join testing on testing.answer_id=answer.answer_id
    join attempt on attempt.attempt_id=testing.attempt_id
    join subject on subject.subject_id=attempt.subject_id
    join student on student.student_id=attempt.student_id
    where attempt.attempt_id=8
    group by student.student_id, subject.subject_id, date_attempt
) as tmp
set attempt.result=tmp.result
where attempt_id=8;


Задание
Удалить из таблицы attempt все попытки, выполненные раньше 1 мая 2020 года. Также удалить и все соответствующие этим попыткам вопросы из таблицы testing, которая создавалась следующим запросом:

CREATE TABLE testing (
    testing_id INT PRIMARY KEY AUTO_INCREMENT,
    attempt_id INT,
    question_id INT,
    answer_id INT,
    FOREIGN KEY (attempt_id)  REFERENCES attempt (attempt_id) ON DELETE CASCADE
);
Фрагмент логической схемы базы данных:



Текст задания (чтобы не прокручивать страницу) :

Удалить из таблицы attempt все попытки, выполненные раньше 1 мая 2020 года. Также удалить и все соответствующие этим попыткам вопросы из таблицы testing.

Результат
Affected rows: 6

Query result:
+------------+------------+------------+--------------+--------+
| attempt_id | student_id | subject_id | date_attempt | result |
+------------+------------+------------+--------------+--------+
| 7          | 3          | 1          | 2020-05-17   | 33     |
| 8          | 1          | 2          | 2020-06-12   | 67     |
+------------+------------+------------+--------------+--------+
Affected rows: 2

Query result:
+------------+------------+-------------+-----------+
| testing_id | attempt_id | question_id | answer_id |
+------------+------------+-------------+-----------+
| 19         | 7          | 1           | 3         |
| 20         | 7          | 4           | 11        |
| 21         | 7          | 5           | 16        |
| 22         | 8          | 7           | 19        |
| 23         | 8          | 6           | 17        |
| 24         | 8          | 8           | 22        |
+------------+------------+-------------+-----------+


3.2.5
delete from attempt
where date_attempt < '2020-05-01'

3.2.6
select student.student_id, subject.subject_id, date_attempt, round(sum(is_correct)/3*100) as result from answer
join testing on testing.answer_id=answer.answer_id
join attempt on attempt.attempt_id=testing.attempt_id
join subject on subject.subject_id=attempt.subject_id
join student on student.student_id=attempt.student_id
where attempt.attempt_id=7
group by student.student_id, subject.subject_id, date_attempt


Задание
Вывести абитуриентов, которые хотят поступать на образовательную программу «Мехатроника и робототехника» в отсортированном по фамилиям виде.

Фрагмент логической схемы базы данных:



Текст задания (чтобы не прокручивать страницу) :

Вывести абитуриентов, которые хотят поступать на образовательную программу «Мехатроника и робототехника» в отсортированном по фамилиям виде.

Результат
+-----------------+
| name_enrollee   |
+-----------------+
| Баранов Павел   |
| Попов Илья      |
| Семенов Иван    |
| Степанова Дарья |
+-----------------+

3.3.2
select name_enrollee from enrollee
join program_enrollee using(enrollee_id)
join program using(program_id)
where program.name_program="Мехатроника и робототехника"
order by name_enrollee



Задание
Вывести образовательные программы, на которые для поступления необходим предмет «Информатика». Программы отсортировать в обратном алфавитном порядке.

Фрагмент логической схемы базы данных:



Текст задания (чтобы не прокручивать страницу) :

 Вывести образовательные программы, на которые для поступления необходим предмет «Информатика». Программы отсортировать в обратном алфавитном порядке.

Результат
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Прикладная математика и информатика |
| Математика и компьютерные науки     |
+-------------------------------------+


select name_program from program
join program_subject using(program_id)
join subject using(subject_id)
where name_subject='Информатика'



Задание
Выведите количество абитуриентов, сдавших ЕГЭ по каждому предмету, максимальное, минимальное и среднее значение баллов по предмету ЕГЭ. Информацию отсортировать по названию предмета в алфавитном порядке, среднее значение округлить до одного знака после запятой.

Фрагмент логической схемы базы данных



Текст задания (чтобы не прокручивать страницу) :

 Выведите количество абитуриентов, сдавших ЕГЭ по каждому предмету, максимальное, минимальное и среднее значение баллов по предмету ЕГЭ. Информацию отсортировать по названию предмета в алфавитном порядке, среднее значение округлить до одного знака после запятой.

Результат
+--------------+------------+----------+---------+---------+
| name_subject | Количество | Максимум | Минимум | Среднее |
+--------------+------------+----------+---------+---------+
| Информатика  | 4          | 94       | 75      | 82.0    |
| Математика   | 6          | 92       | 67      | 75.3    |
| Русский язык | 6          | 90       | 65      | 77.5    |
| Физика       | 5          | 90       | 41      | 69.8    |
+--------------+------------+----------+---------+---------+

3.3.4
select name_subject, count(*) as Количество, max(result) as Максимум, min(result) as Минимум,
round(avg(result), 1) as Среднее
from subject
join enrollee_subject on enrollee_subject.subject_id=subject.subject_id
group by name_subject
order by name_subject


Задание
Вывести образовательные программы, для которых минимальный балл ЕГЭ по каждому предмету больше или равен 40 баллам. Программы вывести в отсортированном по алфавиту виде.

Фрагмент логической схемы базы данных



Текст задания (чтобы не прокручивать страницу) :

Вывести образовательные программы, для которых минимальный балл ЕГЭ по каждому предмету больше или равен 40 баллам. Программы вывести в отсортированном по алфавиту виде.

Результат
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Мехатроника и робототехника         |
| Прикладная математика и информатика |
+-------------------------------------+



3.3.5
select distinct name_program from program
join program_subject on program_subject.program_id=program.program_id
group by name_program
having min(min_result) >= 40
order by name_program

Вывести образовательные программы, которые имеют самый большой план набора,  вместе с этой величиной.

Фрагмент логической схемы базы данных:



Результат
+-----------------------------+------+
| name_program                | plan |
+-----------------------------+------+
| Мехатроника и робототехника | 3    |
+-----------------------------+------+


3.3.6
select name_program, plan from program
where plan=(select max(plan) from program)


Посчитать, сколько дополнительных баллов получит каждый абитуриент. Информацию вывести в отсортированном по фамилиям виде.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) :

Посчитать, сколько дополнительных баллов получит каждый абитуриент. Информацию вывести в отсортированном по фамилиям виде.

Результат
+-----------------+-------+
| name_enrollee   | Бонус |
+-----------------+-------+
| Абрамова Катя   | 0     |
| Баранов Павел   | 6     |
| Попов Илья      | 8     |
| Семенов Иван    | 5     |
| Степанова Дарья | 0     |
| Яковлева Галина | 1     |
+-----------------+-------+

3.3.7
select name_enrollee, ifnull(sum(a.bonus), 0) as Бонус from enrollee e
left join enrollee_achievement ev on e.enrollee_id=ev.enrollee_id
left join achievement a on a.achievement_id=ev.achievement_id
group by name_enrollee
order by name_enrollee


Задание
Выведите сколько человек подало заявление на каждую образовательную программу и конкурс на нее (число поданных заявлений деленное на количество мест по плану), округленный до 2-х знаков после запятой. В запросе вывести название факультета, к которому относится образовательная программа, название образовательной программы, план набора абитуриентов на образовательную программу (plan), количество поданных заявлений (Количество) и Конкурс. Информацию отсортировать в порядке убывания конкурса.

Фрагмент логической схемы базы данных:



Пояснение
Текст задания (чтобы не прокручивать страницу) :

Выведите сколько человек подало заявление на каждую образовательную программу и конкурс на нее (число поданных заявлений деленное на количество мест по плану), округленный до 2-х знаков после запятой. В запросе вывести название факультета, к которому относится образовательная программа, название образовательной программы, план набора абитуриентов на образовательную программу (plan), количество поданных заявлений (Количество) и Конкурс. Информацию отсортировать в порядке убывания конкурса.

Результат
+-------------------------+-------------------------------------+------+------------+---------+
| name_department         | name_program                        | plan | Количество | Конкурс |
+-------------------------+-------------------------------------+------+------------+---------+
| Школа естественных наук | Математика и компьютерные науки     | 1    | 3          | 3.00    |
| Инженерная школа        | Прикладная механика                 | 2    | 4          | 2.00    |
| Школа естественных наук | Прикладная математика и информатика | 2    | 3          | 1.50    |
| Инженерная школа        | Мехатроника и робототехника         | 3    | 4          | 1.33    |
+-------------------------+-------------------------------------+------+------------+---------+

3.3.8
select   name_department, p.name_program, plan, count(*) as Количество, round(count(*)/plan, 2) as Конкурс
from program_enrollee pe
join program p using(program_id)
join department d using(department_id)
group by name_department, p.name_program, plan
order by plan, name_program desc;


Задание
Вывести образовательные программы, на которые для поступления необходимы предмет «Информатика» и «Математика» в отсортированном по названию программ виде.

Логическая схемы базы данных (чтобы потренироваться выбирать таблицы для запроса):



Пояснение
Текст задания (чтобы не прокручивать страницу) :

Вывести образовательные программы, на которые для поступления необходимы предмет «Информатика» и «Математика» в отсортированном по названию программ виде.

Результат
+-------------------------------------+
| name_program                        |
+-------------------------------------+
| Математика и компьютерные науки     |
| Прикладная математика и информатика |
+-------------------------------------+


3.3.9
select p.name_program from subject s
join program_subject ps on s.subject_id=ps.subject_id
join program p on p.program_id=ps.program_id
where name_subject in ('Математика', 'Информатика')
group by name_program
having count(*)=2
order by name_program

